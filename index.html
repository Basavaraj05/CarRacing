<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gamezzz - Enter the World of Gamezzz - Play Now</title>

    <link rel="icon" type="image/png" sizes="32x32" href="./Images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./Images/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./Images/apple-touch-icon.png">
    <link rel="manifest" href="./Images/site.webmanifest">
    <meta name="theme-color" content="#162447">

    <style>
        /* Global Resets and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Add logo styles */
        .nav-logo {
            height: 40px;
            width: 40px; /* Make width equal to height for perfect circle */
            margin-right: 15px;
            border-radius: 50%; /* Make it perfectly round */
            object-fit: cover; /* Ensure the image covers the area properly */
            border: 2px solid #e43f5a; /* Add a border with the theme color */
            padding: 2px; /* Add some padding inside the border */
            background-color: white; /* Add white background */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add subtle shadow */
        }

        .nav-title-container {
            display: flex;
            align-items: center;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            margin: 0;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overscroll-behavior: none;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            line-height: 1.6;
        }
        body.no-scroll-mobile {
            overflow: hidden;
        }


        canvas {
            display: block;
        }

        /* Ad Slot Placeholder Styling (for demonstration) */
        .ad-placeholder {
            width: 100%;
            margin: 20px auto;
            background: #2c2c44; /* Slightly different from page bg */
            border: 1px dashed #505070;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 0.9em;
            min-height: 50px; /* Minimum height for visibility */
        }
        .ad-placeholder-banner { max-width: 728px; height: 90px; }
        .ad-placeholder-box { max-width: 300px; height: 250px; }
        /* --- End Ad Slot Placeholder Styling --- */


        /* Navigation Bar */
        #main-nav {
            background-color: #162447;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 200;
            min-height: 60px;
            position: sticky;
            top: 0;
        }

        #main-nav .nav-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #f8f8f8;
            padding: 10px 0;
        }

        .hamburger-menu {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
            z-index: 201; /* Above nav links container when open */
        }
        .hamburger-menu span {
            display: block;
            width: 25px;
            height: 3px;
            background-color: #e0e0e0;
            margin: 5px 0;
            transition: all 0.3s ease-in-out;
        }

        .nav-links-container {
            display: flex;
            align-items: center;
        }

        .nav-links-container a {
            color: #e0e0e0;
            text-decoration: none;
            padding: 12px 15px;
            margin-left: 5px;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
            font-weight: 500;
            white-space: nowrap;
        }

        .nav-links-container a:hover,
        .nav-links-container a.active {
            background-color: #e43f5a;
            color: #fff;
        }


        /* Page Container and Page Styles */
        .page-container {
            flex-grow: 1;
            position: relative;
            width: 100%;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .page {
            display: none;
            padding: 25px;
            animation: fadeIn 0.5s ease-in-out;
            min-height: calc(100vh - 60px);
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
        }
        .page.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .page h1, .page h2 {
            color: #e43f5a;
            margin-bottom: 25px;
        }
         .page h1 { font-size: 2em; }
         .page h2 { font-size: 1.6em; }

        .page p, .page ul {
            line-height: 1.7;
            max-width: 700px;
            margin-bottom: 18px;
            text-align: left;
            font-size: 1em;
        }
        .page ul {
            list-style-position: inside;
            padding-left: 10px;
        }
        .page ul li {
            margin-bottom: 10px;
        }

        /* Name Entry Page */
        #name-entry-page input[type="text"] {
            padding: 12px 15px;
            font-size: 1.1em;
            border-radius: 5px;
            border: 2px solid #1f4068;
            background-color: #e0e0e0;
            color: #1a1a2e;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }
         #name-entry-page input[type="text"]:focus {
            outline: none;
            border-color: #e43f5a;
            box-shadow: 0 0 8px rgba(228, 63, 90, 0.5);
        }

        .styled-button {
            padding: 12px 25px;
            font-size: 1.1em;
            color: white;
            background-color: #e43f5a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
            box-shadow: 0 4px #a32d40;
        }
        .styled-button:hover {
            background-color: #f5506e;
        }
        .styled-button:active {
            background-color: #d0304a;
            box-shadow: 0 2px #a32d40;
            transform: translateY(2px);
        }

        /* Game Page Specific */
        #game-page {
            padding: 0;
            overflow: hidden;
            background-color: #a0d7e6; /* Initial, will be updated by JS */
            touch-action: none; /* Important for mobile page-level gestures */
        }

        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #111; /* Slightly less dark to differentiate from potential black artifacts */
            color: white;
            display: flex; /* Changed from none to flex for initial visibility managed by JS */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.7s ease-out;
            text-align: center;
        }
        #loading-screen.hidden {
             opacity: 0;
             pointer-events: none;
        }
        #loading-progress {
            font-size: 0.6em;
            margin-top: 15px;
            color: #aaa;
        }

        #countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6em; /* Large text */
            color: white;
            text-shadow: 2px 2px 8px black, 0 0 15px black;
            z-index: 1002;
            display: none;
            font-weight: bold;
            text-align: center;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 1px 1px 3px black, 0 0 5px black;
            z-index: 50;
            font-size: 1.3em;
        }
        #score { margin-bottom: 6px; font-weight: bold; }
        #distance { margin-bottom: 6px; font-weight: bold; }
        #speedometer { font-size: 0.85em; }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3333;
            font-size: 2.2em;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 6px black, 0 0 10px black;
            display: none;
            z-index: 101;
            padding: 20px;
            background-color: rgba(10,10,20,0.8);
            border-radius: 15px;
            flex-direction: column;
            align-items: center;
            width: 90%;
            max-width: 400px;
        }
        #game-over-title {
            margin-bottom: 15px;
        }
        #final-score-display {
            font-size: 0.55em;
            margin-bottom:15px;
            color: #fff;
        }
        #game-over button {
            display: block;
            margin-top: 12px;
            padding: 10px 20px;
            font-size: 0.48em;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
            width: 85%;
            max-width: 220px;
        }
        #restart-button { background-color: #4CAF50; box-shadow: 0 4px #388E3C; }
        #restart-button:active { background-color: #45a049; box-shadow: 0 2px #388E3C; transform: translateY(2px); }
        #view-leaderboard-button { background-color: #007bff; box-shadow: 0 4px #0056b3; }
        #view-leaderboard-button:active { background-color: #0069d9; box-shadow: 0 2px #0056b3; transform: translateY(2px); }
        #main-menu-button { background-color: #6c757d; box-shadow: 0 4px #545b62; }
        #main-menu-button:active { background-color: #5a6268; box-shadow: 0 2px #545b62; transform: translateY(2px); }


        .control-button {
            position: absolute;
            width: 70px;
            height: 70px;
            background-color: rgba(200, 200, 200, 0.45);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 60;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2em;
            color: rgba(0, 0, 0, 0.8);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s ease;
            touch-action: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .control-button:active {
            background-color: rgba(255, 255, 255, 0.65);
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        #left-button { 
            left: 25px; 
            bottom: 120px; 
        }

        #right-button { 
            right: 25px; 
            bottom: 120px; 
        }

        @media (max-width: 768px) {
            .control-button {
                width: 65px;
                height: 65px;
                font-size: 2em;
            }
            #left-button { 
                left: 20px; 
                bottom: 110px; 
            }
            #right-button { 
                right: 20px; 
                bottom: 110px; 
            }
        }

        @media (max-width: 480px) {
            .control-button {
                width: 60px;
                height: 60px;
                font-size: 1.8em;
            }
            #left-button { 
                left: 15px; 
                bottom: 100px; 
            }
            #right-button { 
                right: 15px; 
                bottom: 100px; 
            }
        }


        /* Leaderboard Page Styles */
        #leaderboard-page {
            background-color: #1a1a2e;
            color: #e0e0e0;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            padding: 25px;
            border-radius: 10px;
        }
        #leaderboard-page h2 {
            margin-bottom: 25px;
            color: #ffdd57;
            font-size: 1.8em;
        }
        #leaderboard-list {
            list-style-type: none;
            padding-left: 0;
            margin: 0 auto;
            width: 100%;
        }
        #leaderboard-list li {
            margin-bottom: 12px;
            font-size: 1em;
            text-align: left;
            border-bottom: 1px solid #1f4068;
            padding: 10px 8px;
            display: flex;
            justify-content: space-between;
            background-color: rgba(31, 64, 104, 0.2);
            border-radius: 5px;
        }
         #leaderboard-list li .leaderboard-name {
            font-weight: bold;
            color: #e0e0e0;
            margin-right: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #leaderboard-list li .leaderboard-score {
            color: #ffdd57;
            white-space: nowrap;
        }
        #leaderboard-list li:first-child {
            background-color: rgba(255, 221, 87, 0.15);
            border-left: 3px solid #ffdd57;
        }
        #leaderboard-list li:last-child { border-bottom: none; }

        #close-leaderboard-button {
            margin-top: 30px;
        }
        #no-scores-message {
            font-style: italic;
            color: #aaa;
            font-size: 1em;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) { /* Medium screens / Tablets */
            .nav-logo { height: 35px; width: 35px; }
            #main-nav .nav-title { font-size: 1.2em; }
            #main-nav { padding: 0 15px; }
            .hamburger-menu { display: block; }
            .nav-links-container {
                display: none; position: absolute; top: 60px; left: 0; right: 0;
                background-color: #162447; flex-direction: column; width: 100%;
                padding: 10px 0; box-shadow: 0 5px 10px rgba(0,0,0,0.2); z-index: 199;
            }
            .nav-links-container.open { display: flex; }
            .nav-links-container a {
                width: 100%; text-align: center; padding: 15px 20px; margin-left: 0;
                border-bottom: 1px solid rgba(255,255,255,0.1);
            }
            .nav-links-container a:last-child { border-bottom: none; }
            .hamburger-menu[aria-expanded="true"] span:nth-child(1) { transform: translateY(8px) rotate(45deg); }
            .hamburger-menu[aria-expanded="true"] span:nth-child(2) { opacity: 0; }
            .hamburger-menu[aria-expanded="true"] span:nth-child(3) { transform: translateY(-8px) rotate(-45deg); }

            .page { padding: 20px; }
            .page h1 { font-size: 1.8em; } .page h2 { font-size: 1.5em; }
            .page p, .page ul { font-size: 0.95em; }
            #ui-container { font-size: 1.1em; top: 8px; left: 8px; }
            #countdown-display { font-size: 5em; }


            .control-button {
                width: 60px; height: 60px; font-size: 1.9em;
            }
             #left-button { left: 15px; bottom: 110px; }
             #right-button { right: 15px; bottom: 110px; }


            #game-over { font-size: 1.8em; padding: 15px; }
            #game-over button { font-size: 0.5em; padding: 10px 15px; }
            .ad-placeholder-box { max-width: 100%; height: 200px; }
            #leaderboard-page h2 { font-size: 1.6em; }
            #leaderboard-list li { font-size: 0.95em; }
        }

        @media (max-width: 480px) { /* Small screens / Mobiles */
            .nav-logo { height: 30px; width: 30px; }
            #main-nav .nav-title { font-size: 1.1em; }
            .page { padding: 15px; }
            .page h1 { font-size: 1.6em; } .page h2 { font-size: 1.3em; }
            .page p, .page ul { font-size: 0.9em; }
            #name-entry-page input[type="text"] { font-size: 1em; }
            .styled-button { font-size: 1em; padding: 10px 20px; }
            #loading-screen { font-size: 1.8em; } #loading-progress { font-size: 0.5em; }
            #ui-container { font-size: 1em; }
            #countdown-display { font-size: 4em; }

            .control-button {
                width: 55px; height: 55px; font-size: 1.7em;
            }
             #left-button { left: 10px; bottom: 110px; }
             #right-button { right: 10px; bottom: 110px; }

            #game-over { font-size: 1.6em; }
            #final-score-display { font-size: 0.5em; }
            #game-over button { font-size: 0.45em; }
            .ad-placeholder-banner { height: 50px; }
            .ad-placeholder-box { height: 150px; }
            #leaderboard-page h2 { font-size: 1.4em; }
            #leaderboard-list li { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <nav id="main-nav">
        <div class="nav-title-container">
            <img src="./Images/logo1.png" alt="Gamezzz Logo" class="nav-logo">
            <div class="nav-title">Gamezzz</div>
        </div>
        <button class="hamburger-menu" aria-label="Toggle menu" aria-expanded="false">
            <span></span>
            <span></span>
            <span></span>
        </button>
        <div class="nav-links-container">
            <a href="#" data-page="name-entry-page">Play</a>
            <a href="#" data-page="leaderboard-page">Leaderboard</a>
            <a href="#" data-page="about-page">About</a>
            <a href="#" data-page="privacy-policy-page">Privacy Policy</a>
            <a href="#" data-page="contact-us-page">Contact Us</a>
        </div>
    </nav>

    <div class="page-container">
        <!-- Name Entry Page -->
        <div id="name-entry-page" class="page">
            <h1>Enter Your Name</h1>
            <input type="text" id="player-name-input" placeholder="Player Name" maxlength="15">
            <button id="start-game-button" class="styled-button">Start Game</button>
            <p style="margin-top: 20px; font-size: 0.9em; color: #bbb;">Enter your name to appear on the leaderboard!</p>
            <div id="ad-slot-name-entry" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
        </div>

        <!-- Game Page -->
        <div id="game-page" class="page">
            <div id="loading-screen"> <!-- Initially visible -->
                <div>LOADING ASSETS</div>
                <div id="loading-progress">0%</div>
            </div>
            <div id="countdown-display">3</div>
            <div id="container"></div>

            <div id="ui-container">
                <div id="score">Score: 0</div>
                <div id="distance">Distance: 0 m</div>
                <div id="speedometer">Speed: 0 km/h</div>
            </div>
            <div id="game-over">
                <div id="game-over-title">GAME OVER!</div>
                <div id="final-score-display"></div>
                <div id="ad-slot-game-over" class="ad-placeholder ad-placeholder-box">Ad Placeholder (e.g., Box Ad)</div>
                <button id="restart-button">Play Again</button>
                <button id="view-leaderboard-button">View Leaderboard</button>
                <button id="main-menu-button">Main Menu</button>
            </div>

            <div id="left-button" class="control-button">◀</div>
            <div id="right-button" class="control-button">▶</div>
        </div>

        <!-- Leaderboard Page -->
        <div id="leaderboard-page" class="page">
            <h2>High Scores</h2>
            <div id="ad-slot-leaderboard-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            <ol id="leaderboard-list"></ol>
            <div id="no-scores-message" style="display:none;">No high scores yet. Be the first!</div>
            <button id="close-leaderboard-button" class="styled-button">Back to Menu</button>
        </div>

        <!-- About Page -->
        <div id="about-page" class="page">
            <div>
                <h1>About 3D Racer</h1>
                <div id="ad-slot-about-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
                <p>Welcome to 3D Racer, an enhanced 3D car driving experience!</p>
                <p>This game is built using Three.js, a powerful 3D graphics library for the web. Drive as far as you can, collect points, and avoid crashing into other vehicles. Experience a dynamic day-night cycle and even occasional rain!</p>
                <p>Features:</p>
                <ul>
                    <li>Dynamic 3D environment with buildings, street lights, and traffic elements.</li>
                    <li>Realistic car physics simulation (basic).</li>
                    <li>Day-night cycle affecting lighting and visuals. (Currently forced daytime for performance)</li>
                    <li>Weather effects like rain (using InstancedMesh for performance).</li>
                    <li>Score and distance tracking.</li>
                    <li>Leaderboard to compete for the highest distance.</li>
                    <li>Touch controls for mobile (steering) and keyboard controls for desktop (steering).</li>
                    <li>Automatic acceleration after a countdown.</li>
                </ul>
                <p>This project is a demonstration of what can be achieved with modern web technologies. Have fun racing!</p>
                <div id="ad-slot-about-bottom" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            </div>
        </div>

        <!-- Privacy Policy Page -->
        <div id="privacy-policy-page" class="page">
            <div>
                <h1>Privacy Policy</h1>
                <div id="ad-slot-privacy-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
                <p><strong>Last updated: [Current Date]</strong></p>
                <p>This Privacy Policy describes Our policies and procedures on the collection, use and disclosure of Your information when You use the Service and tells You about Your privacy rights and how the law protects You.</p>

                <h2>1. Information We Collect</h2>
                <p>This game ("3D Racer") collects the following information:</p>
                <ul>
                    <li><strong>Player Name:</strong> If you choose to enter a name, it will be stored locally on your device in your browser's Local Storage to be displayed on the leaderboard. This name is not transmitted to any server by us.</li>
                    <li><strong>Game Scores (Distance):</strong> Your game scores (distance achieved) are stored locally on your device in your browser's Local Storage to maintain a local leaderboard. This data is not transmitted to any server by us.</li>
                </ul>

                <h2>2. How We Use Your Information</h2>
                <p>The information collected is used solely for the following purposes:</p>
                <ul>
                    <li>To display your name and score on the in-game leaderboard, which is local to your browser.</li>
                    <li>To allow you to track your high scores over time.</li>
                </ul>

                <h2>3. Data Storage and Security</h2>
                <p>All data (player name and scores) is stored in your web browser's Local Storage. We do not have access to this data, nor is it transmitted to any external servers. The security of this data depends on the security of your own device and browser.</p>

                <h2>4. Third-Party Services</h2>
                <p>This game uses assets (like 3D models, sounds, and JavaScript libraries) hosted on third-party services (e.g., unpkg.com, threejs.org, mixkit.co, gstatic.com). These services may have their own privacy policies and may collect data according to their terms. We are not responsible for the privacy practices of these third-party services.</p>

                <h2>5. Children's Privacy</h2>
                <p>Our Service does not address anyone under the age of 13. We do not knowingly collect personally identifiable information from anyone under the age of 13. If you are a parent or guardian and You are aware that Your child has provided Us with Personal Data without your consent, please contact Us. If We become aware that We have collected Personal Data from anyone under the
13 without verification of parental consent, We take steps to remove that information from Our servers (though in this game's case, it's local storage, which you can clear via browser settings).</p>

                <h2>6. Changes to This Privacy Policy</h2>
                <p>We may update Our Privacy Policy from time to time. We will notify You of any changes by posting the new Privacy Policy on this page.</p>
                <p>You are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are effective when they are posted on this page.</p>

                <h2>7. Contact Us</h2>
                <p>If you have any questions about this Privacy Policy, You can contact us: [Provide a placeholder email or contact method, e.g., by email: contact@example.com]</p>
                <div id="ad-slot-privacy-bottom" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            </div>
        </div>

        <!-- Contact Us Page -->
        <div id="contact-us-page" class="page">
            <div>
                <h1>Contact Us</h1>
                <div id="ad-slot-contact-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
                <p>If you have any questions, feedback, or inquiries about the 3D Racer game, please feel free to reach out.</p>
                <p><strong>Email:</strong> <a href="mailto:feedback@example.com" style="color: #e43f5a;">feedback@example.com</a> (This is a placeholder email)</p>
                <p><strong>GitHub/Project Page:</strong> (If applicable, link to your project repository or website here)</p>
                <p>We appreciate your interest and will do our best to respond in a timely manner.</p>
                <div id="ad-slot-contact-bottom" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            </div>
        </div>
    </div>

    <!-- stats.js, if you want to include it locally or from a CDN -->
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>

     <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

        // --- Performance Monitoring ---
        let stats;

        // --- Page Navigation and State ---
        const pages = document.querySelectorAll('.page');
        const mainNav = document.getElementById('main-nav');
        const navLinksFromContainer = document.querySelectorAll('.nav-links-container a[data-page]');
        const pageContainer = document.querySelector('.page-container');
        let currentPageId = 'name-entry-page';
        let currentPlayerName = localStorage.getItem('3DRacerPlayerName') || "Player";
        let gameInitialized = false;
        let assetsCurrentlyLoading = false;

        const playerNameInput = document.getElementById('player-name-input');
        const startGameButton = document.getElementById('start-game-button');

        const hamburger = document.querySelector('.hamburger-menu');
        const navLinksContainer = document.querySelector('.nav-links-container');

        playerNameInput.value = currentPlayerName === "Player" ? "" : currentPlayerName;

        function handleAdSlotVisibility(slotId) {
            // const adSlot = document.getElementById(slotId);
            // if (adSlot) { console.log(`Ad slot ${slotId} is now visible.`); }
        }

        function showPage(pageId) {
            const gamePage = document.getElementById('game-page');
            const oldPageId = currentPageId;

            if (pageId === 'game-page') {
                document.body.style.overflow = 'hidden';
                pageContainer.style.overflowY = 'hidden';
                if (gamePage) gamePage.style.touchAction = 'none'; // Already present, good for page level
                if (stats) stats.dom.style.display = 'block';
            } else {
                document.body.style.overflow = 'auto';
                pageContainer.style.overflowY = 'auto';
                if (gamePage) gamePage.style.touchAction = 'auto';
                if (stats) stats.dom.style.display = 'none';

                if (oldPageId === 'game-page') {
                     if (sounds.engine) stopSound('engine');
                     if (sounds.rain) stopSound('rain');
                     if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        if(countdownDisplayElement) countdownDisplayElement.style.display = 'none';
                        isCountingDown = false;
                    }
                }
            }

            pages.forEach(page => {
                if (page.id === pageId) {
                    page.classList.add('active');
                    const adSlotsOnPage = page.querySelectorAll('.ad-placeholder[id]');
                    adSlotsOnPage.forEach(slot => handleAdSlotVisibility(slot.id));
                } else {
                    page.classList.remove('active');
                }
            });
            navLinksFromContainer.forEach(link => {
                link.classList.toggle('active', link.dataset.page === pageId);
            });

            currentPageId = pageId;

            if (pageId === 'game-page') {
                if (!gameInitialized && !assetsCurrentlyLoading) {
                    assetsCurrentlyLoading = true;
                    console.log("Starting initial game and asset loading...");
                    initThreeJSGame();
                } else if (gameInitialized) {
                    console.log("Game already initialized, restarting game logic.");
                    restartGame();
                }
            }

            if (pageId === 'leaderboard-page') displayLeaderboard();
            if (pageId === 'game-over') handleAdSlotVisibility('ad-slot-game-over');
            window.scrollTo(0, 0);
        }

        navLinksFromContainer.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageIdToLoad = link.dataset.page;
                showPage(pageIdToLoad);

                if (navLinksContainer.classList.contains('open')) {
                    hamburger.setAttribute('aria-expanded', 'false');
                    navLinksContainer.classList.remove('open');
                    document.body.classList.remove('no-scroll-mobile');
                }
            });
        });

        startGameButton.addEventListener('click', () => {
            const name = playerNameInput.value.trim();
            currentPlayerName = name || "Player";
            localStorage.setItem('3DRacerPlayerName', currentPlayerName);
            showPage('game-page');
        });


        hamburger.addEventListener('click', () => {
            const isExpanded = hamburger.getAttribute('aria-expanded') === 'true';
            hamburger.setAttribute('aria-expanded', String(!isExpanded));
            navLinksContainer.classList.toggle('open');
            document.body.classList.toggle('no-scroll-mobile', !isExpanded);
        });

        // --- Game Variables ---
        let scene, camera, renderer, carModel, enemyCar, clock;
        let ambientLight, directionalLight, lensflare;
        let road, kerbs = []; // roadLines removed, handled by roadLineInstanceMesh
        let buildings = [], streetLights = [], trafficLights = [];
        let clouds = [];
        let cloudMaterial;
        let stars = null;
        const numStarsBase = 300;

        const roadWidth = 10;
        const roadLength = 200; // This defines one "segment" of road
        const buildingSpacingBase = 15;
        const lightSpacingBase = 30;

        let effectiveNumBuildings, effectiveNumLights, effectiveNumClouds, effectiveNumStars;
        let reduceEnvironmentComplexityMobile = false;

        const kerbHeight = 0.2; const kerbWidth = 0.3; const enemyCarSpeedFactor = 0.65;

        let carVelocity = 0;
        let carAcceleration = 0.005; // Reduced from 0.0045
        let carDeceleration = 0.002;
        let maxSpeed = 1.0;          // Reduced from 1.8
        let currentDisplaySpeed = 0;
        const baseDriveSpeed = 0.8;

        // Instanced Mesh variables
        let roadLineInstanceMesh;
        const MAX_ROAD_LINES = Math.floor(roadLength / (3 + 5)) + 10; // lineLength + lineGap, plus buffer

        let rainInstanceMesh, rainInstanceData = [];
        const MAX_RAIN_PARTICLES_INSTANCED = 150; // Tunable

        let exhaustInstanceMesh, exhaustInstanceData = [];
        const MAX_EXHAUST_PARTICLES_INSTANCED = 25; // Tunable

        let skidInstanceMesh, skidInstanceData = [];
        const MAX_SKID_MARKS_INSTANCED = 40; // Tunable
        let nextSkidMarkIndex = 0;
        let lastSkidTime = 0; const skidInterval = 120; // Slightly increased interval

        let isRaining = false;
        let timeOfDay = 0.5;
        let baseFogNear = roadLength * 0.4; let baseFogFar = roadLength * 0.9;

        const sounds = {};
        if (typeof Audio !== "undefined") {
            sounds.engine = new Audio('./sound effect/11L-Generate_a_racing_ca-1746887375438.mp3');
            // sounds.collect = new Audio('./sound effect/collect.mp3');
            // sounds.skid = new Audio('./sound effect/skid.mp3');
            // sounds.nearMiss = new Audio('./sound effect/nearMiss.mp3');
            // sounds.rain = new Audio('./sound effect/rain.mp3');
            if (sounds.engine) sounds.engine.addEventListener('error', (e) => console.error('Error loading engine sound:', e));
            Object.values(sounds).filter(s => s).forEach(sound => sound.volume = 0.5);
            if(sounds.engine) sounds.engine.volume = 0.3;
        }

        let enemyTargetX = 0; let enemyLaneChangeTimer = 0; const enemyLaneChangeInterval = 1500; const enemyLaneChangeProbability = 0.5;
        let moveLeft = false; let moveRight = false;
        let gameHasStartedAfterCountdown = false;
        let isCountingDown = false;
        let countdownValue = 3;
        let countdownInterval = null;

        const carTurnSpeed = 0.18; let carBaseY = 0.5; let carCurrentYOffset = 0;
        const suspensionStiffness = 0.2; const suspensionDamping = 0.15; let suspensionVelocity = 0;
        let score = 0; let distanceTraveled = 0; let isGameOver = false; let nearMissCooldown = 0; const nearMissBonus = 5;
        const points = []; const numPoints = 10; const pointValue = 10;
        let pointGeometry, pointMaterial; const pointRadius = 0.35;
        let coinPatterns = ['left', 'right', 'middle']; let currentPatternIndex = 0; let coinsInCurrentPattern = 0; let targetCoinsForPattern = 5 + Math.floor(Math.random() * 3);

        const scoreElement = document.getElementById('score');
        const distanceElement = document.getElementById('distance');
        const speedometerElement = document.getElementById('speedometer');
        const gameOverElement = document.getElementById('game-over');
        const finalScoreDisplayElement = document.getElementById('final-score-display');
        const restartButton = document.getElementById('restart-button');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgressElement = document.getElementById('loading-progress');
        const leaderboardListElement = document.getElementById('leaderboard-list');
        const noScoresMessageElement = document.getElementById('no-scores-message');
        const closeLeaderboardButton = document.getElementById('close-leaderboard-button');
        const viewLeaderboardButton = document.getElementById('view-leaderboard-button');
        const mainMenuButton = document.getElementById('main-menu-button');
        const countdownDisplayElement = document.getElementById('countdown-display');

        const LEADERBOARD_KEY = 'carGameLeaderboard_Daytime_v3_Named'; const MAX_LEADERBOARD_ENTRIES = 10;
        let playerBox = new THREE.Box3(); let enemyBox = new THREE.Box3(); let pointBox = new THREE.Box3();
        let playerSize = new THREE.Vector3(); let enemySize = new THREE.Vector3();
        const baseFov = 70;

        const GAP_AFTER_LOADING_MS = 700;

        // UI Update Throttling
        let lastUiUpdateTime = 0;
        const UI_UPDATE_INTERVAL = 100; // milliseconds (10 times per second)

        // Three.js Helpers for matrix operations
        const _tempMatrix = new THREE.Matrix4();
        const _tempVector3 = new THREE.Vector3();
        const _tempQuaternion = new THREE.Quaternion();
        const _tempEuler = new THREE.Euler();
        const _tempObject = new THREE.Object3D();


        const loadingManager = new THREE.LoadingManager();
        loadingManager.onStart = (url, itemsLoaded, itemsTotal) => {
            console.log(`Loading started. Total items: ${itemsTotal}`);
            assetsCurrentlyLoading = true;
            loadingScreen.classList.remove('hidden');
            loadingProgressElement.textContent = `0%`;
        };
        loadingManager.onLoad = () => {
            console.log("All assets loaded by LoadingManager.");
            assetsCurrentlyLoading = false;

            if(renderer && scene && camera) {
                 try {
                    renderer.render(scene, camera);
                    console.log("Rendered one frame after asset load.");
                } catch (e) {
                    console.error("Error rendering frame after load:", e);
                }
            } else {
                 console.warn("Renderer, scene or camera not ready for post-load render.");
            }

            setTimeout(() => {
                console.log("Gap after loading finished. Hiding loading screen and starting countdown.");
                loadingScreen.classList.add('hidden');
                gameInitialized = true;

                if (currentPageId === 'game-page' && !isGameOver && !isCountingDown) {
                    initiateCountdown();
                } else {
                    console.log("Not on game page, or game over, or already counting down. No countdown initiated from loadingManager.");
                }
            }, GAP_AFTER_LOADING_MS);
        };
        loadingManager.onError = (url) => {
            console.error(`Error loading ${url}. Asset loading might be incomplete.`);
            assetsCurrentlyLoading = false;
            loadingProgressElement.textContent = `Error loading assets.`;
        };
        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            const progress = Math.round((itemsLoaded / itemsTotal) * 100);
            loadingProgressElement.textContent = `${progress}%`;
        };

        let headlightLeft, headlightRight, taillightLeft, taillightRight;

        function updatePerformanceSettings() {
            const isMobileDevice = window.innerWidth <= 768;
            reduceEnvironmentComplexityMobile = isMobileDevice;

            if (renderer) {
                // Increase pixel ratio for better graphics
                const pixelRatio = Math.min(window.devicePixelRatio, isMobileDevice ? 1.5 : 2.0);
                renderer.setPixelRatio(pixelRatio);
                
                // Enable antialiasing for better graphics
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Better shadow quality
            }

            if (directionalLight && directionalLight.shadow) {
                // Increase shadow map size for better quality
                const shadowMapSize = isMobileDevice ? 512 : 1024;
                if (directionalLight.shadow.mapSize.width !== shadowMapSize) {
                    directionalLight.shadow.mapSize.width = shadowMapSize;
                    directionalLight.shadow.mapSize.height = shadowMapSize;
                    if (directionalLight.shadow.map) {
                        directionalLight.shadow.map.dispose();
                        directionalLight.shadow.map = null;
                    }
                }
            }

            // Adjust environment complexity based on device
            if (reduceEnvironmentComplexityMobile) {
                effectiveNumBuildings = Math.floor(roadLength / (buildingSpacingBase * 1.5));
                effectiveNumLights = Math.floor(roadLength / (lightSpacingBase * 1.5));
                effectiveNumClouds = 8;
                effectiveNumStars = 100;
            } else {
                effectiveNumBuildings = Math.floor(roadLength / buildingSpacingBase);
                effectiveNumLights = Math.floor(roadLength / lightSpacingBase);
                effectiveNumClouds = 20;
                effectiveNumStars = numStarsBase;
            }
        }

        function createWindowTexture(baseColorHex, buildingWidth, buildingHeight) {
            const canvas = document.createElement('canvas');
            const S = reduceEnvironmentComplexityMobile ? 48 : 128;
            canvas.width = S; canvas.height = S * 1.5;
            const ctx = canvas.getContext('2d');
            const baseColorStr = new THREE.Color(baseColorHex).getStyle();
            ctx.fillStyle = baseColorStr; ctx.fillRect(0, 0, canvas.width, canvas.height);

            const N_col = reduceEnvironmentComplexityMobile ? 1 : 3;
            const N_row = reduceEnvironmentComplexityMobile ? 2 : 5;
            const cellWidth = canvas.width / N_col; const cellHeight = canvas.height / N_row;
            const windowPadWidth = cellWidth * 0.15; const windowPadHeight = cellHeight * 0.12;
            const windowWidth = cellWidth - 2 * windowPadWidth; const windowHeight = cellHeight - 2 * windowPadHeight;
            for (let r = 0; r < N_row; r++) {
                for (let c = 0; c < N_col; c++) {
                    if (Math.random() > 0.1) {
                        let currentWindowColor = '#354048';
                        ctx.fillStyle = currentWindowColor;
                        ctx.fillRect(c * cellWidth + windowPadWidth, r * cellHeight + windowPadHeight, windowWidth, windowHeight);
                    }
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            if (renderer) texture.anisotropy = renderer.capabilities.getMaxAnisotropy() / (reduceEnvironmentComplexityMobile ? 2 : 1);
            const metersPerTileWidth = 4; const metersPerTileHeight = 5;
            texture.repeat.set(buildingWidth / metersPerTileWidth, buildingHeight / metersPerTileHeight);
            texture.needsUpdate = true;
            return texture;
        }

        function initThreeJSGame() {
            console.log("initThreeJSGame called.");
            loadingScreen.classList.remove('hidden');
            loadingProgressElement.textContent = `0%`;

            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6);
            scene.fog = new THREE.Fog(0xa0d7e6, baseFogNear, baseFogFar);

            camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Stats.js
            stats = new Stats();
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '70px'; // Adjust so it doesn't overlap nav
            stats.dom.style.left = '10px';
            stats.dom.style.display = 'none'; // Initially hidden, shown with game page
            document.body.appendChild(stats.dom);


            const isMobileForRenderer = window.innerWidth <= 768;
            try {
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                updatePerformanceSettings();
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2; // Slightly increased for better visibility
                const container = document.getElementById('container');
                container.innerHTML = '';
                container.appendChild(renderer.domElement);
            } catch (e) {
                console.error("Error initializing WebGL Renderer:", e);
                loadingProgressElement.textContent = "Error: WebGL not supported or failed to initialize.";
                assetsCurrentlyLoading = false;
                return;
            }

            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(50, 100, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.5;
            // Tighter shadow frustum
            directionalLight.shadow.camera.left = -roadLength * 0.25;
            directionalLight.shadow.camera.right = roadLength * 0.25;
            directionalLight.shadow.camera.top = roadLength * 0.25;
            directionalLight.shadow.camera.bottom = -roadLength * 0.25;
            directionalLight.shadow.camera.far = 180; // Reduced far plane for shadows
            // Shadow map size set in updatePerformanceSettings
            scene.add(directionalLight);


            const textureLoader = new THREE.TextureLoader(loadingManager);
            if (!reduceEnvironmentComplexityMobile) {
                try {
                    const textureFlare0 = textureLoader.load("https://threejs.org/examples/textures/lensflare/lensflare0.png");
                    const textureFlare3 = textureLoader.load("https://threejs.org/examples/textures/lensflare/lensflare3.png");
                    lensflare = new Lensflare();
                    lensflare.addElement(new LensflareElement(textureFlare0, 700, 0, directionalLight.color));
                    lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
                    lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
                    lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
                    lensflare.addElement(new LensflareElement(textureFlare3, 70, 1.0));
                    directionalLight.add(lensflare);
                } catch (e) {
                    console.warn("Could not load lensflare textures:", e);
                    lensflare = null;
                }
            } else {
                lensflare = null;
            }

            const groundGeo = new THREE.PlaneGeometry(roadLength * 2, roadLength);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a7936, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2; ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8, metalness: 0.1 });
            road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2; road.position.y = 0;
            road.receiveShadow = true;
            scene.add(road);

            // Instanced Road Lines
            const lineLength = 3; const lineGap = 5;
            const numRoadLinesToCreate = Math.floor(roadLength / (lineLength + lineGap)) + 10; // Buffer
            const lineGeo = new THREE.PlaneGeometry(0.25, lineLength);
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            roadLineInstanceMesh = new THREE.InstancedMesh(lineGeo, lineMat, numRoadLinesToCreate);
            roadLineInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            const lineDummy = new THREE.Object3D();
            lineDummy.rotation.x = -Math.PI / 2;
            lineDummy.position.y = 0.0051; // Slightly above road
            for (let i = 0; i < numRoadLinesToCreate; i++) {
                lineDummy.position.z = (roadLength / 2) - (lineLength / 2) - i * (lineLength + lineGap);
                lineDummy.updateMatrix();
                roadLineInstanceMesh.setMatrixAt(i, lineDummy.matrix);
            }
            roadLineInstanceMesh.instanceMatrix.needsUpdate = true;
            scene.add(roadLineInstanceMesh);


            const kerbTexture = createKerbTexture();
            kerbTexture.wrapS = THREE.RepeatWrapping; kerbTexture.repeat.set(roadLength / 5, 1);
            const kerbGeo = new THREE.BoxGeometry(kerbWidth, kerbHeight, roadLength);
            const kerbMat = new THREE.MeshStandardMaterial({ map: kerbTexture, roughness: 0.7 });
            kerbs = [];
            [-1, 1].forEach(side => {
                const kerb = new THREE.Mesh(kerbGeo, kerbMat.clone());
                kerb.position.set(side * (roadWidth / 2 + kerbWidth / 2), kerbHeight / 2, 0);
                kerb.castShadow = false;
                kerb.receiveShadow = true;
                kerbs.push(kerb); scene.add(kerb);
            });

            cloudMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff, transparent: true, opacity: 0.6, depthWrite: false
            });

            createEnvironmentAssets(); // Buildings, StreetLights, Clouds, Stars

            pointGeometry = new THREE.SphereGeometry(pointRadius, reduceEnvironmentComplexityMobile ? 8 : 12, reduceEnvironmentComplexityMobile ? 6 : 8);
            pointMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0xeeaa00, emissiveIntensity: 0.7, roughness: 0.3 });
            points.length = 0;
            for (let i = 0; i < numPoints; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial.clone());
                point.castShadow = false; point.receiveShadow = false;
                points.push(point);
                resetPointPosition(point, true);
                scene.add(point);
            }

            // Initialize Instanced Particle Systems
            createRainParticleSystem_Instanced();
            createExhaustParticleSystem_Instanced();
            createSkidMarkSystem_Instanced();

            loadCarModels();

            window.addEventListener('resize', onWindowResize, false);
            restartButton.addEventListener('click', restartGame);
            viewLeaderboardButton.addEventListener('click', () => { gameOverElement.style.display = 'none'; showPage('leaderboard-page'); });
            mainMenuButton.addEventListener('click', () => { gameOverElement.style.display = 'none'; showPage('name-entry-page'); });
            closeLeaderboardButton.addEventListener('click', () => showPage('name-entry-page'));

            setupControls();
            updateScoreDisplay(); updateDistanceDisplay(); updateSpeedometer();
            updateDayCycleAndWeather(0);
            animate();
        }

        function createKerbTexture() {
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 32; const stripeWidth = 16; const colors = ['#dd0000', '#eeeeee'];
            for (let i = 0; i < canvas.width / stripeWidth; i++) { ctx.fillStyle = colors[i % 2]; ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height); }
            const texture = new THREE.CanvasTexture(canvas);
            if (renderer) texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;
            return texture;
        }

        function createEnvironmentAssets() {
            const buildingBaseColors = [ 0xaaaaaa, 0x888890, 0x999080, 0x777777, 0x605550, 0xacb2b7, 0xb5a89a, 0x5a6469 ];
            function createBuilding() {
                const height = Math.random() * 25 + 15; const width = Math.random() * 6 + 5; const depth = Math.random() * 6 + 5;
                const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                const selectedBaseColorHex = buildingBaseColors[Math.floor(Math.random() * buildingBaseColors.length)];
                const wallTexture = createWindowTexture(selectedBaseColorHex, width, height);
                const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.6 + Math.random() * 0.3, metalness: Math.random() * 0.1, color: 0xffffff });
                const roofColor = new THREE.Color(selectedBaseColorHex).multiplyScalar(0.8);
                const roofMaterial = new THREE.MeshStandardMaterial({ color: roofColor, roughness: 0.8, metalness: 0.1 });
                const building = new THREE.Mesh(buildingGeo, [wallMaterial, wallMaterial, roofMaterial, roofMaterial, wallMaterial, wallMaterial]);
                building.position.y = height / 2 - 0.04; building.castShadow = true; building.receiveShadow = true; return building;
            }
            buildings.forEach(b => scene.remove(b)); // Clear old if any (for potential re-init logic)
            buildings = [];
            for (let i = 0; i < effectiveNumBuildings; i++) {
                [-1, 1].forEach(side => {
                    const building = createBuilding();
                    const currentBuildingSpacing = buildingSpacingBase * (reduceEnvironmentComplexityMobile ? 2.0 : 1.0);
                    const zPos = (roadLength / 2) - (currentBuildingSpacing / 2) - i * currentBuildingSpacing + (Math.random()-0.5) * currentBuildingSpacing * 0.5;
                    const xOffset = roadWidth / 2 + kerbWidth + 2 + Math.random() * 8 + building.geometry.parameters.width / 2;
                    building.position.set(side * xOffset, building.position.y, zPos);
                    buildings.push(building); scene.add(building);
                });
            }

            function createStreetLight() {
                const group = new THREE.Group(); const poleHeight = 7; const poleRadius = 0.1; const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius * 1.2, poleHeight, reduceEnvironmentComplexityMobile? 6:8); const poleMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.9, roughness: 0.3 }); const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.castShadow = true; pole.position.y = poleHeight/2; group.add(pole);
                const armLength = 1.5; const armGeo = new THREE.BoxGeometry(armLength, poleRadius * 1.8, poleRadius * 1.8); const arm = new THREE.Mesh(armGeo, poleMat);
                arm.castShadow = true; arm.position.set(0, poleHeight - poleRadius * 2.5, 0); group.add(arm);
                const lightFixtureGeo = new THREE.SphereGeometry(poleRadius * 2.5, reduceEnvironmentComplexityMobile ? 6 : 16, reduceEnvironmentComplexityMobile ? 3 : 8); const lightFixtureMat = new THREE.MeshStandardMaterial({ color: 0xffffdd, emissive: 0xffffaa, emissiveIntensity: 0 });  const lightFixture = new THREE.Mesh(lightFixtureGeo, lightFixtureMat);
                lightFixture.castShadow = false; lightFixture.position.set(0, poleHeight - poleRadius * 2.5, 0); group.add(lightFixture);
                const pointLight = new THREE.PointLight(0xffffee, 0, 15, 1.5);
                pointLight.castShadow = false; pointLight.visible = false;
                lightFixture.add(pointLight);
                group.userData = { armLength: armLength, fixture: lightFixture, light: pointLight }; return group;
            }
            streetLights.forEach(sl => scene.remove(sl));
            streetLights = [];
            for (let i = 0; i < effectiveNumLights; i++) {
                const zPos = (roadLength / 2) - (lightSpacingBase / 2) - i * lightSpacingBase + (Math.random()-0.5) * lightSpacingBase * 0.5;
                [-1, 1].forEach(side => {
                    const light = createStreetLight();
                    const xPos = roadWidth / 2 + kerbWidth + 1.0;
                    light.position.set(side * xPos, 0, zPos);
                    light.rotation.y = side > 0 ? -Math.PI / 2.5 : Math.PI / 2.5;
                    light.children[1].position.x = -light.userData.armLength / 2; light.children[2].position.x = -light.userData.armLength;
                    streetLights.push(light); scene.add(light);
                });
            }

            trafficLights.forEach(tl => scene.remove(tl));
            trafficLights = []; // Not implemented visually yet

            clouds.forEach(c => scene.remove(c));
            clouds = [];
            for (let i = 0; i < effectiveNumClouds; i++) {
                const cloudGroup = new THREE.Group();
                const numSpheres = reduceEnvironmentComplexityMobile ? (Math.floor(Math.random() * 2) + 2) : (Math.floor(Math.random() * 5) + 3);
                for(let j=0; j < numSpheres; j++) {
                    const size = Math.random() * 5 + 3;
                    const cloudPartGeo = new THREE.SphereGeometry(size, reduceEnvironmentComplexityMobile ? 6:8, reduceEnvironmentComplexityMobile ? 4:6);
                    const cloudPart = new THREE.Mesh(cloudPartGeo, cloudMaterial.clone()); // Clone material for individual opacity/color changes later if needed
                    cloudPart.position.set( (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 3 );
                    cloudGroup.add(cloudPart);
                }
                cloudGroup.position.set( (Math.random() - 0.5) * roadLength * 1.5, Math.random() * 20 + 40, (Math.random() - 0.5) * roadLength * 1.5 );
                cloudGroup.userData.speed = Math.random() * 0.02 + 0.01;
                clouds.push(cloudGroup); scene.add(cloudGroup);
            }

            if (stars && stars.geometry) stars.geometry.dispose(); if (stars && stars.material) stars.material.dispose(); scene.remove(stars);
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, sizeAttenuation: true, transparent: true, opacity: 0, depthWrite: false });
            const starVertices = [];
            for (let i = 0; i < effectiveNumStars; i++) {
                starVertices.push(THREE.MathUtils.randFloatSpread(roadLength * 3), THREE.MathUtils.randFloat(50, 150), THREE.MathUtils.randFloatSpread(roadLength * 3));
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function loadCarModels() {
            console.log("loadCarModels called.");
            const loader = new GLTFLoader(loadingManager);
            const dracoLoader = new DRACOLoader(loadingManager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
            loader.setDRACOLoader(dracoLoader);
            const carUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb';

            loader.load(carUrl, (gltf) => {
                console.log("Ferrari GLB loaded successfully.");
                carModel = gltf.scene; carModel.scale.set(0.7,0.7,0.7);
                const tempBox = new THREE.Box3().setFromObject(carModel); tempBox.getSize(playerSize);
                carBaseY = -tempBox.min.y * carModel.scale.y + 0.02; carModel.position.set(0, carBaseY, -5); carModel.rotation.y = Math.PI;
                carModel.traverse((node) => { if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; } });
                scene.add(carModel);
                headlightLeft = new THREE.SpotLight(0xffffee,0,30,Math.PI/6,0.3,1); headlightLeft.castShadow = false; headlightLeft.visible = false;
                headlightLeft.position.set(-0.7,0.6,2.0).multiplyScalar(carModel.scale.x); carModel.add(headlightLeft); carModel.add(headlightLeft.target);
                headlightLeft.target.position.set(-0.6,0.3,10).multiplyScalar(carModel.scale.x);
                headlightRight = headlightLeft.clone(); headlightRight.visible = false; headlightRight.position.set(0.7,0.6,2.0).multiplyScalar(carModel.scale.x);
                carModel.add(headlightRight); carModel.add(headlightRight.target); headlightRight.target.position.set(0.6,0.3,10).multiplyScalar(carModel.scale.x);
                taillightLeft = new THREE.PointLight(0xff0000,0,5,2); taillightLeft.position.set(-0.8,0.5,-2.2).multiplyScalar(carModel.scale.x); carModel.add(taillightLeft);
                taillightRight = taillightLeft.clone(); taillightRight.position.set(0.8,0.5,-2.2).multiplyScalar(carModel.scale.x); carModel.add(taillightRight);
                enemyCar = carModel.clone(); const tempEnemyBox = new THREE.Box3().setFromObject(enemyCar); tempEnemyBox.getSize(enemySize);
                enemyCar.traverse((node) => {
                    if (node.isMesh) { const blueMaterial = node.material.clone(); blueMaterial.color.setHex(0x3366ff); node.material = blueMaterial; node.castShadow = true; node.receiveShadow = true; }
                    if (node.isLight) node.intensity = 0;
                });
                resetEnemyCar(); scene.add(enemyCar);
                camera.position.set(0,carBaseY+2.8,carModel.position.z-6.5); camera.lookAt(carModel.position.x,carBaseY+1.0,carModel.position.z+3.0);
            },
            null,
            (error) => {
                console.error('Error loading car model (ferrari.glb):', error);
                const fallbackGeo = new THREE.BoxGeometry(1.8,1,3.5); playerSize.set(1.8,1,3.5); enemySize.copy(playerSize);
                const fallbackMat = new THREE.MeshStandardMaterial({color:0xff0000}); carModel = new THREE.Mesh(fallbackGeo,fallbackMat);
                carBaseY = 0.5+0.01; carModel.position.set(0,carBaseY,-5); carModel.castShadow = true; carModel.receiveShadow = true;
                scene.add(carModel); camera.position.set(0,carBaseY+2.8,carModel.position.z-6.5); camera.lookAt(carModel.position.x,carBaseY+1.0,carModel.position.z+3.0);
            });
        }

        function initiateCountdown() {
            console.log("initiateCountdown called.");
            if (countdownInterval) clearInterval(countdownInterval);
            isGameOver = false;
            isCountingDown = true;
            gameHasStartedAfterCountdown = false;
            countdownValue = 3;

            if(carModel) {
                carModel.position.set(0, carBaseY, -5);
                carModel.rotation.set(0, Math.PI, 0);
            }
            carVelocity = 0;
            // updateSpeedometer(); // Will be updated by throttled UI update

            if (countdownDisplayElement) {
                countdownDisplayElement.textContent = countdownValue;
                countdownDisplayElement.style.display = 'block';
            } else {
                console.warn("Countdown display element not found!");
            }
            if (sounds.engine) stopSound('engine');

             if (!loadingScreen.classList.contains('hidden')) {
                loadingScreen.classList.add('hidden');
            }

            countdownInterval = setInterval(() => {
                countdownValue--;
                if (countdownDisplayElement) {
                    if (countdownValue > 0) {
                        countdownDisplayElement.textContent = countdownValue;
                    } else if (countdownValue === 0) {
                        countdownDisplayElement.textContent = "GO!";
                    } else {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        countdownDisplayElement.style.display = 'none';
                        isCountingDown = false;
                        gameHasStartedAfterCountdown = true;
                        console.log("Countdown finished. Game started!");
                        if (!isGameOver && currentPageId === 'game-page' && sounds.engine) {
                            playSound('engine', true);
                        }
                    }
                } else {
                     clearInterval(countdownInterval);
                     countdownInterval = null;
                     isCountingDown = false;
                     gameHasStartedAfterCountdown = true;
                     console.log("Countdown finished (no display element). Game started!");
                     if (!isGameOver && currentPageId === 'game-page' && sounds.engine) playSound('engine', true);
                }
            }, 1000);
        }


        function setupControls() {
            window.addEventListener('keydown', (event) => {
                if (isGameOver || isCountingDown || currentPageId !== 'game-page') return;
                switch (event.key.toLowerCase()) {
                    case 'arrowleft': case 'a': moveLeft = true; break;
                    case 'arrowright': case 'd': moveRight = true; break;
                    case 'r': isRaining = !isRaining; updateRainSound(); break;
                }
            });
            window.addEventListener('keyup', (event) => {
                if (currentPageId !== 'game-page') return;
                switch (event.key.toLowerCase()) {
                    case 'arrowleft': case 'a': moveLeft = false; break;
                    case 'arrowright': case 'd': moveRight = false; break;
                }
            });

            const leftBtn = document.getElementById('left-button');
            const rightBtn = document.getElementById('right-button');

            // Prevent default touch behaviors on the game page
            const gamePage = document.getElementById('game-page');
            if (gamePage) {
                gamePage.addEventListener('touchmove', (e) => {
                    if (currentPageId === 'game-page') {
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            // Improved touch event handling
            const handleTouchStart = (e, direction) => {
                if (!isGameOver && !isCountingDown && currentPageId === 'game-page') {
                    e.preventDefault();
                    if (direction === 'left') moveLeft = true;
                    if (direction === 'right') moveRight = true;
                }
            };

            const handleTouchEnd = (e, direction) => {
                if (currentPageId === 'game-page') {
                    e.preventDefault();
                    if (direction === 'left') moveLeft = false;
                    if (direction === 'right') moveRight = false;
                }
            };

            // Add touch events with proper handling
            if (leftBtn) {
                leftBtn.addEventListener('touchstart', (e) => handleTouchStart(e, 'left'), { passive: false });
                leftBtn.addEventListener('touchend', (e) => handleTouchEnd(e, 'left'), { passive: false });
                leftBtn.addEventListener('touchcancel', (e) => handleTouchEnd(e, 'left'), { passive: false });
            }

            if (rightBtn) {
                rightBtn.addEventListener('touchstart', (e) => handleTouchStart(e, 'right'), { passive: false });
                rightBtn.addEventListener('touchend', (e) => handleTouchEnd(e, 'right'), { passive: false });
                rightBtn.addEventListener('touchcancel', (e) => handleTouchEnd(e, 'right'), { passive: false });
            }

            // Add visual feedback for touch controls
            const addTouchFeedback = (button) => {
                if (!button) return;
                button.addEventListener('touchstart', () => {
                    button.style.backgroundColor = 'rgba(255, 255, 255, 0.65)';
                }, { passive: true });
                button.addEventListener('touchend', () => {
                    button.style.backgroundColor = 'rgba(200, 200, 200, 0.45)';
                }, { passive: true });
                button.addEventListener('touchcancel', () => {
                    button.style.backgroundColor = 'rgba(200, 200, 200, 0.45)';
                }, { passive: true });
            };

            addTouchFeedback(leftBtn);
            addTouchFeedback(rightBtn);
        }

        function updateRainSound() {
             if (!sounds.rain) return;
             if (isRaining && currentPageId === 'game-page' && !isGameOver && !isCountingDown) playSound('rain', true);
             else stopSound('rain');
        }

        function restartGame() {
            console.log("restartGame called.");
            isGameOver = false;
            score = 0; distanceTraveled = 0; carVelocity = 0; currentDisplaySpeed = 0;
            carCurrentYOffset = 0; suspensionVelocity = 0;
            currentPatternIndex = 0; coinsInCurrentPattern = 0; targetCoinsForPattern = 5 + Math.floor(Math.random() * 3);
            lastUiUpdateTime = 0; // Reset UI update timer

            resetEnemyCar();
            points.forEach(p => resetPointPosition(p, true));

            // Reset Instanced Meshes
            if (skidInstanceMesh) {
                skidInstanceData = [];
                skidInstanceMesh.count = 0;
                if(skidInstanceMesh.instanceMatrix) skidInstanceMesh.instanceMatrix.needsUpdate = true;
                nextSkidMarkIndex = 0;
            }
            if (exhaustInstanceMesh) {
                exhaustInstanceData = [];
                exhaustInstanceMesh.count = 0;
                if(exhaustInstanceMesh.instanceMatrix) exhaustInstanceMesh.instanceMatrix.needsUpdate = true;
            }
            if (rainInstanceMesh) {
                rainInstanceData.forEach(data => data.active = false); // Deactivate all
                rainInstanceMesh.count = 0; // Visually hide
                if(rainInstanceMesh.instanceMatrix) rainInstanceMesh.instanceMatrix.needsUpdate = true;
            }
            if (roadLineInstanceMesh) { // Reset main roadLineInstanceMesh position
                roadLineInstanceMesh.position.z = 0;
            }


            gameOverElement.style.display = 'none';
            updateScoreDisplay(); updateDistanceDisplay(); updateSpeedometer(); // Initial update

            if (sounds.engine) stopSound('engine');
            updateRainSound();
            updateDayCycleAndWeather(0);
            if (camera) { camera.fov = baseFov; camera.updateProjectionMatrix(); }

            initiateCountdown();
        }

        function resetEnemyCar() {
             if (!enemyCar || !carModel) return; enemyCar.rotation.y = 0;
            const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 4) * (0.8 + Math.random() * 0.4);
            const initialEnemyZ = carModel.position.z + roadLength * (0.7 + Math.random() * 0.5);
            enemyCar.position.set(initialEnemyX, carBaseY, initialEnemyZ);
            enemyTargetX = initialEnemyX; enemyCar.visible = true;
        }

        function resetPointPosition(point, initial = false) {
            const laneXOffset = roadWidth / 4; let targetX;
            if (coinsInCurrentPattern >= targetCoinsForPattern) {
                currentPatternIndex = (currentPatternIndex + 1) % coinPatterns.length;
                coinsInCurrentPattern = 0; targetCoinsForPattern = 5 + Math.floor(Math.random() * 3);
            }
            const currentPattern = coinPatterns[currentPatternIndex];
            switch (currentPattern) { case 'left': targetX = -laneXOffset; break; case 'right': targetX = laneXOffset; break; default: targetX = 0; }
            point.position.x = targetX; point.position.y = pointRadius + 0.02;
            const carZ = carModel ? carModel.position.z : 0;
            if (initial) { point.position.z = carZ + 20 + (points.indexOf(point) * 12); }
            else {
                let furthestVisibleCoinZInLane = carZ;
                points.forEach(p => { if (p.visible && p !== point && Math.abs(p.position.x - targetX) < 0.01 && p.position.z > furthestVisibleCoinZInLane) furthestVisibleCoinZInLane = p.position.z; });
                const ZSpacingInPattern = 10 + Math.random() * 5; const minZFromCar = carZ + roadLength * 0.4;
                let newZ = (furthestVisibleCoinZInLane > carZ) ? furthestVisibleCoinZInLane + ZSpacingInPattern : minZFromCar + Math.random() * roadLength * 0.2;
                point.position.z = Math.max(newZ, minZFromCar);
            }
            coinsInCurrentPattern++; point.visible = true;
        }

        function updateScoreDisplay() { if(scoreElement) scoreElement.textContent = `Score: ${score}`; }
        function updateDistanceDisplay() { if(distanceElement) distanceElement.textContent = `Distance: ${Math.floor(distanceTraveled)} m`; }
        function updateSpeedometer() {
             currentDisplaySpeed = Math.floor(Math.abs(carVelocity * 100));
             if(speedometerElement) speedometerElement.textContent = `Speed: ${currentDisplaySpeed} km/h`;
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            const newWidth = window.innerWidth; const newHeight = window.innerHeight;
            updatePerformanceSettings(); // This will also update renderer pixel ratio
            camera.aspect = newWidth / newHeight; camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);
        }

        // --- Instanced Particle System: Rain ---
        function createRainParticleSystem_Instanced() {
            if (rainInstanceMesh) scene.remove(rainInstanceMesh);
            const rainGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.7, reduceEnvironmentComplexityMobile ? 3 : 5); // Simpler geo
            const rainMat = new THREE.MeshBasicMaterial({ color:0xabcdef, transparent:true, opacity:0.3, depthWrite: false });
            rainInstanceMesh = new THREE.InstancedMesh(rainGeo, rainMat, MAX_RAIN_PARTICLES_INSTANCED);
            rainInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            rainInstanceMesh.visible = false; // Initially hidden
            scene.add(rainInstanceMesh);
            rainInstanceData = [];
            for (let i = 0; i < MAX_RAIN_PARTICLES_INSTANCED; i++) {
                const yPos = camera.position.y + Math.random() * 25 + 15; // Start higher and more spread
                rainInstanceData.push({
                    matrix: new THREE.Matrix4().setPosition(
                        camera.position.x + (Math.random() - 0.5) * roadWidth * 4, // Wider spread
                        yPos,
                        camera.position.z + (Math.random() - 0.5) * roadLength * 0.8
                    ),
                    initialY: yPos,
                    speed: 1.2 + Math.random() * 0.8, // Base speed
                    active: false // All inactive initially
                });
            }
        }

        function updateRainParticles_Instanced(delta) {
            if (!rainInstanceMesh || !isRaining || !gameHasStartedAfterCountdown) {
                if(rainInstanceMesh) rainInstanceMesh.visible = false;
                return;
            }
            rainInstanceMesh.visible = true;
            let activeCount = 0;
            const tiltAngle = -carVelocity * 0.07; // Rain tilting with speed

            rainInstanceData.forEach((data, i) => {
                if (!data.active && Math.random() < 0.05) { // Chance to activate a particle
                    data.active = true;
                     _tempObject.position.set(
                        camera.position.x + (Math.random() - 0.5) * roadWidth * 4,
                        data.initialY + (Math.random() - 0.5) * 10, // Respawn height variation
                        camera.position.z + (Math.random() - 0.5) * roadLength * 0.8 + carVelocity * 10 // Spawn ahead
                    );
                    _tempObject.updateMatrix();
                    data.matrix.copy(_tempObject.matrix);
                }

                if (data.active) {
                    _tempObject.matrix.copy(data.matrix);
                    _tempObject.matrix.decompose(_tempObject.position, _tempObject.quaternion, _tempObject.scale);

                    _tempObject.position.y -= (data.speed + carVelocity * 0.4) * delta * 10; // Adjusted speed logic
                     _tempEuler.set(tiltAngle, 0, (Math.random() - 0.5) * 0.1); // Slight random Z rotation
                    _tempObject.quaternion.setFromEuler(_tempEuler);


                    if (_tempObject.position.y < camera.position.y - 5) { // Recycle below camera view
                        data.active = false; // Deactivate
                    } else {
                        _tempObject.updateMatrix();
                        data.matrix.copy(_tempObject.matrix);
                        rainInstanceMesh.setMatrixAt(activeCount, data.matrix);
                        activeCount++;
                    }
                }
            });
            rainInstanceMesh.count = activeCount;
            rainInstanceMesh.instanceMatrix.needsUpdate = true;
        }

        // --- Instanced Particle System: Exhaust ---
        function createExhaustParticleSystem_Instanced() {
            if (exhaustInstanceMesh) scene.remove(exhaustInstanceMesh);
            const exhaustGeo = new THREE.SphereGeometry(0.08, reduceEnvironmentComplexityMobile ? 4 : 6, reduceEnvironmentComplexityMobile ? 2 : 3); // Slightly larger base
            const exhaustMat = new THREE.MeshBasicMaterial({ color:0xcccccc, transparent:true, opacity:0.4, depthWrite:false });
            exhaustInstanceMesh = new THREE.InstancedMesh(exhaustGeo, exhaustMat, MAX_EXHAUST_PARTICLES_INSTANCED);
            exhaustInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(exhaustInstanceMesh);
            exhaustInstanceData = []; // { matrix, age, maxAge, active }
        }

        function addExhaustInstance_Instanced() {
            if (!carModel || !exhaustInstanceMesh || !gameHasStartedAfterCountdown || carVelocity < 0.1) return;

            let availableIndex = -1;
            for(let i=0; i < exhaustInstanceData.length; i++) {
                if(!exhaustInstanceData[i].active) {
                    availableIndex = i;
                    break;
                }
            }
            if (availableIndex === -1 && exhaustInstanceData.length < MAX_EXHAUST_PARTICLES_INSTANCED) {
                availableIndex = exhaustInstanceData.length;
                exhaustInstanceData.push({ matrix: new THREE.Matrix4(), age:0, maxAge:0.8 + Math.random()*0.4, active:false});
            }

            if(availableIndex !== -1) {
                const data = exhaustInstanceData[availableIndex];
                data.active = true;
                data.age = 0;
                data.maxAge = 0.6 + Math.random()*0.3 + carVelocity * 0.2; // Max age depends on speed

                _tempObject.position.copy(carModel.position);
                // Offset relative to car's back, considering car's rotation
                const localOffset = new THREE.Vector3((Math.random()-0.5)*0.3, -0.15, -1.9 * (carModel.scale.z || 0.8));
                localOffset.applyQuaternion(carModel.quaternion);
                _tempObject.position.add(localOffset);
                _tempObject.position.y = Math.max(0.15, _tempObject.position.y); // Keep above ground

                _tempObject.quaternion.identity(); // No rotation for spheres
                _tempObject.scale.set(0.1,0.1,0.1); // Initial small scale
                _tempObject.updateMatrix();
                data.matrix.copy(_tempObject.matrix);
            }
        }

        function updateExhaustParticles_Instanced(delta) {
            if (!exhaustInstanceMesh || !gameHasStartedAfterCountdown) return;
            let activeCount = 0;

            if (carVelocity > 0.1 && Math.random() < 0.6) { // Chance to add new particle
                 addExhaustInstance_Instanced();
            }

            exhaustInstanceData.forEach(data => {
                if(data.active) {
                    data.age += delta;
                    if (data.age > data.maxAge) {
                        data.active = false;
                    } else {
                        _tempObject.matrix.copy(data.matrix);
                        _tempObject.matrix.decompose(_tempObject.position, _tempObject.quaternion, _tempObject.scale);

                        _tempObject.position.y += (0.01 + carVelocity * 0.005) * (1 - data.age/data.maxAge); // Rise and slow down
                        _tempObject.position.x -= carVelocity * 0.003 * (1 - data.age/data.maxAge); // Drift back
                        _tempObject.position.z -= carVelocity * baseDriveSpeed * delta * 0.3; // Move with world slightly slower than car

                        const scaleFactor = 0.1 + (data.age / data.maxAge) * (0.8 + carVelocity * 0.3); // Grow
                        _tempObject.scale.set(scaleFactor, scaleFactor, scaleFactor);

                        // Opacity in material for all instances, or use per-instance color if shader modified
                        // For now, let global material opacity handle fade (less ideal)
                        // Or, if using MeshStandardMaterial, could use vertex colors to control opacity if shader allows

                        _tempObject.updateMatrix();
                        data.matrix.copy(_tempObject.matrix);
                        exhaustInstanceMesh.setMatrixAt(activeCount, data.matrix);
                        activeCount++;
                    }
                }
            });
            exhaustInstanceMesh.count = activeCount;
            if(activeCount > 0) exhaustInstanceMesh.instanceMatrix.needsUpdate = true;
            // A global opacity fade might be needed on exhaustInstanceMesh.material if particles don't individually fade
            exhaustInstanceMesh.material.opacity = Math.max(0.1, 0.6 - (activeCount / MAX_EXHAUST_PARTICLES_INSTANCED) * 0.5);

        }


        // --- Instanced Particle System: Skid Marks ---
        function createSkidMarkSystem_Instanced() {
            if (skidInstanceMesh) scene.remove(skidInstanceMesh);
            const skidGeo = new THREE.PlaneGeometry(0.4, 1.2); // Width, Length of skid mark
            const skidMat = new THREE.MeshStandardMaterial({
                color:0x1a1a1a, transparent:true, opacity:0.8,
                roughness:0.9, depthWrite:false, side: THREE.DoubleSide
            });
            skidInstanceMesh = new THREE.InstancedMesh(skidGeo, skidMat, MAX_SKID_MARKS_INSTANCED);
            skidInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(skidInstanceMesh);
            skidInstanceData = []; // { matrix, age, maxAge, active }
            nextSkidMarkIndex = 0;
        }

        function addSkidMarkInstance_Instanced(worldPosition, carRotationY) {
            if (!skidInstanceMesh || !gameHasStartedAfterCountdown) return;

            const data = skidInstanceData[nextSkidMarkIndex];
            if (!data) { // Initialize if not present
                skidInstanceData[nextSkidMarkIndex] = { matrix: new THREE.Matrix4(), age:0, maxAge: 3 + Math.random()*2, active:false};
            }
            const currentData = skidInstanceData[nextSkidMarkIndex];
            currentData.active = true;
            currentData.age = 0;
            currentData.maxAge = 2.5 + Math.random()*1.5 + carVelocity * 0.5; // Longer skid at higher speed

            _tempObject.position.copy(worldPosition);
            _tempObject.position.y = 0.011; // Slightly above road, above road lines

            // Apply car's overall rotation, then the skid's specific orientation
            _tempEuler.set(-Math.PI / 2, 0, carRotationY - Math.PI/2); // Plane needs to be flat, then rotated
            _tempObject.quaternion.setFromEuler(_tempEuler);

            _tempObject.scale.set(1,1,1); // Base scale

            _tempObject.updateMatrix();
            currentData.matrix.copy(_tempObject.matrix);

            nextSkidMarkIndex = (nextSkidMarkIndex + 1) % MAX_SKID_MARKS_INSTANCED;
        }

        function updateSkidMarks_Instanced(delta, worldMovementZ) {
            if (!skidInstanceMesh) return;
            let activeCount = 0;
            skidInstanceData.forEach(data => {
                if(data.active) {
                    data.age += delta;
                    if (data.age > data.maxAge) {
                        data.active = false; // Deactivate when too old
                    } else {
                        // Skid marks are static on the ground, their matrix doesn't change until they fade
                        // However, they need to scroll with the world
                        _tempObject.matrix.copy(data.matrix);
                        _tempObject.matrix.decompose(_tempObject.position, _tempObject.quaternion, _tempObject.scale);
                        _tempObject.position.z -= worldMovementZ; // Scroll with the world

                        // Fade out effect by scaling down or reducing opacity via shader attributes (more advanced)
                        // Simple approach: could scale Y to 0, but that's not opacity.
                        // For now, we rely on replacing old ones. True opacity fade needs shader work or individual materials.

                        _tempObject.updateMatrix();
                        data.matrix.copy(_tempObject.matrix);

                        skidInstanceMesh.setMatrixAt(activeCount, data.matrix);
                        activeCount++;
                    }
                }
            });
            skidInstanceMesh.count = activeCount;
            if (activeCount > 0) skidInstanceMesh.instanceMatrix.needsUpdate = true;
        }


        function animate() {
            requestAnimationFrame(animate);
            if (!renderer || !scene || !camera || !carModel) return;
            if (stats) stats.begin();

            if (currentPageId !== 'game-page' && !isGameOver) {
                if (stats) stats.end();
                return;
            }

            const delta = clock.getDelta();
            const nowTime = clock.elapsedTime * 1000;

            if (isCountingDown) {
                if(renderer && scene && camera) renderer.render(scene, camera);
                if (stats) stats.end();
                return;
            }

            if (isGameOver) {
                if (sounds.engine && sounds.engine.volume > 0.01) {
                    sounds.engine.volume -= 0.01;
                    sounds.engine.playbackRate = Math.max(0.1, sounds.engine.playbackRate - 0.01);
                } else stopSound('engine');
                if(renderer && scene && camera) renderer.render(scene, camera);
                if (stats) stats.end();
                return;
            }

            if (currentPageId !== 'game-page') { // Should be caught earlier, but as a safeguard
                 if (stats) stats.end();
                 return;
            }


            let prevCarVelocity = carVelocity;
            if (gameHasStartedAfterCountdown && !isGameOver) {
                carVelocity = Math.min(carVelocity + carAcceleration, maxSpeed);
            } else {
                carVelocity = Math.max(carVelocity - carDeceleration, 0);
            }
            let accelerationEffect = (delta > 0) ? (carVelocity - prevCarVelocity) / delta : 0;

            const actualSpeed = carVelocity * baseDriveSpeed;
            const worldMovementZ = actualSpeed * delta * 60; // Normalize speed based on 60FPS delta

            if (gameHasStartedAfterCountdown && carVelocity > 0) {
                distanceTraveled += worldMovementZ * 2; // Scale distance as desired
            }

            let targetRotationZ = 0;
            const effectiveTurnSpeed = carTurnSpeed * (1 + carVelocity * 0.5);
            playerBox.setFromObject(carModel); // More accurate AABB
            const carWidth = playerSize.x;
            const maxBounds = roadWidth / 2 - kerbWidth - carWidth / 2 - 0.1;
            let turningEffect = 0;

            if (gameHasStartedAfterCountdown && !isGameOver) {
                let newX = carModel.position.x;

                if (moveLeft) {
                    newX -= effectiveTurnSpeed * delta * 60; // Normalize turn speed
                    targetRotationZ = Math.PI / 20;
                    turningEffect = -0.05;
                }
                if (moveRight) {
                    newX += effectiveTurnSpeed * delta * 60; // Normalize turn speed
                    targetRotationZ = -Math.PI / 20;
                    turningEffect = 0.05; // Corrected sign for right turn effect
                }


                if (newX >= -maxBounds && newX <= maxBounds) {
                    carModel.position.x = newX;
                     if ((moveLeft || moveRight) && carVelocity > 0.3 && Date.now() - lastSkidTime > skidInterval) {
                        addSkidMarkInstance_Instanced(carModel.getWorldPosition(new THREE.Vector3()), carModel.rotation.y + targetRotationZ * 2.5);
                        lastSkidTime = Date.now();
                        if (sounds.skid && Math.random() < 0.3) playSound('skid', false, 0.3);
                    }
                }
                 carModel.position.x = THREE.MathUtils.clamp(carModel.position.x, -maxBounds, maxBounds);
            }


            carModel.rotation.z = THREE.MathUtils.lerp(carModel.rotation.z, targetRotationZ * carVelocity, 0.1);

            let force = -suspensionStiffness * carCurrentYOffset - suspensionDamping * suspensionVelocity + accelerationEffect * 0.005 + turningEffect * carVelocity * 0.1;
            suspensionVelocity += force * delta; carCurrentYOffset += suspensionVelocity * delta;
            carCurrentYOffset = THREE.MathUtils.clamp(carCurrentYOffset, -0.05, 0.05);
            carModel.position.y = carBaseY + carCurrentYOffset;

            // Scroll non-instanced objects
            const objectsToScroll = [ ...buildings, ...streetLights, ...trafficLights, ...kerbs, ...points ];
            if (enemyCar && enemyCar.visible) objectsToScroll.push(enemyCar);
            objectsToScroll.forEach(obj => obj.position.z -= worldMovementZ);

            // Scroll Instanced Road Lines (by moving the entire InstancedMesh)
            if (roadLineInstanceMesh) {
                roadLineInstanceMesh.position.z -= worldMovementZ;
                if (roadLineInstanceMesh.position.z < -roadLength / 2 - 20) { // Recycle when half off-screen
                    roadLineInstanceMesh.position.z += roadLength;
                }
            }


            const recycleThreshold = -roadLength / 2 - 20;
            // roadLines.forEach(line => { if (line.position.z < recycleThreshold) line.position.z += roadLength; }); // Handled by roadLineInstanceMesh
            kerbs.forEach(kerb => { if (kerb.position.z < recycleThreshold - roadLength / 2) kerb.position.z += roadLength * 2; }); // Kerbs are long, recycle full length
            buildings.forEach(building => {
                if (building.position.z < recycleThreshold - building.geometry.parameters.depth) {
                    const currentBuildingSpacing = buildingSpacingBase * (reduceEnvironmentComplexityMobile ? 2.0 : 1.0);
                    building.position.z += roadLength + Math.random() * currentBuildingSpacing * 1.5;
                    const sideSign = Math.sign(building.position.x) || (Math.random() < 0.5 ? -1 : 1);
                    const xOffset = roadWidth / 2 + kerbWidth + 2 + Math.random() * 8 + building.geometry.parameters.width / 2;
                    building.position.x = sideSign * xOffset;
                }
            });
            streetLights.forEach(light => { if (light.position.z < recycleThreshold) light.position.z += roadLength + Math.random() * lightSpacingBase * 2; });
            trafficLights.forEach(light => { if (light.position.z < recycleThreshold) light.position.z += roadLength * 1.5 + Math.random() * roadLength; });
            points.forEach(point => { if (point.position.z < carModel.position.z - 20 && point.visible) resetPointPosition(point); });


            updateDayCycleAndWeather(delta); // This will call updateRainParticles_Instanced
            updateEnemyAI(delta, worldMovementZ);
            updateExhaustParticles_Instanced(delta);
            updateSkidMarks_Instanced(delta, worldMovementZ); // Skid marks also need to scroll


            const targetCameraPos = new THREE.Vector3( carModel.position.x*0.25, carModel.position.y + 2.5 + carVelocity*0.4, carModel.position.z - 6.5 - carVelocity*2.0 );
            camera.position.lerp(targetCameraPos, 0.12);
            const lookAtPos = new THREE.Vector3( carModel.position.x*0.4, carModel.position.y + 1.0, carModel.position.z + 4.0 );
            camera.lookAt(lookAtPos);
            camera.fov = THREE.MathUtils.lerp(camera.fov, baseFov + carVelocity * 8, 0.05);
            camera.updateProjectionMatrix();

            points.forEach(point => {
                if (!point.visible) return; pointBox.setFromObject(point);
                if (playerBox.intersectsBox(pointBox)) {
                    score += pointValue;
                    // updateScoreDisplay(); // Throttled
                    point.visible = false;
                    if(sounds.collect) playSound('collect', false, 0.6);
                    setTimeout(() => { if(!point.visible) resetPointPosition(point);}, 500 + Math.random()*1000);
                }
            });

            if (enemyCar && enemyCar.visible) {
                enemyBox.setFromObject(enemyCar); // More accurate AABB
                if (playerBox.intersectsBox(enemyBox)) handleGameOver();
                else if (nearMissCooldown <= 0) {
                    const distZ = Math.abs(carModel.position.z - enemyCar.position.z); const distX = Math.abs(carModel.position.x - enemyCar.position.x);
                    const carCombinedHalfWidth = playerSize.x/2 + enemySize.x/2; const carCombinedHalfLength = playerSize.z/2 + enemySize.z/2;
                    if (distZ < carCombinedHalfLength*1.5 && distX < carCombinedHalfWidth*1.8 && distX > carCombinedHalfWidth*0.9 && carVelocity > 0.3) {
                        score += nearMissBonus;
                        // updateScoreDisplay(); // Throttled
                        if(sounds.nearMiss) playSound('nearMiss', false, 0.4); nearMissCooldown = 1.5;
                    }
                }
            }
            if (nearMissCooldown > 0) nearMissCooldown -= delta;

            // Throttled UI Updates
            if (nowTime - lastUiUpdateTime > UI_UPDATE_INTERVAL) {
                updateScoreDisplay();
                updateDistanceDisplay();
                updateSpeedometer();
                lastUiUpdateTime = nowTime;
            }

            if(gameHasStartedAfterCountdown) updateEngineSound();
            if(renderer && scene && camera) renderer.render(scene, camera);
            if (stats) stats.end();
        }

        function handleGameOver() {
             if (isGameOver) return;
             console.log("Game Over!");
             isGameOver = true; gameHasStartedAfterCountdown = false;
            if(finalScoreDisplayElement) finalScoreDisplayElement.textContent = `Distance: ${Math.floor(distanceTraveled)} m | Score: ${score}`;
            gameOverElement.style.display = 'flex'; handleAdSlotVisibility('ad-slot-game-over');
            saveScoreToLeaderboard(currentPlayerName, Math.floor(distanceTraveled));
            if (sounds.rain) stopSound('rain');
        }

        function saveScoreToLeaderboard(playerName, currentDistance) {
            if (!playerName) playerName = "Player";
            try {
                const scoresJSON = localStorage.getItem(LEADERBOARD_KEY); let scores = scoresJSON ? JSON.parse(scoresJSON) : [];
                scores.push({ name: playerName, score: currentDistance });
                scores.sort((a, b) => b.score - a.score); scores = scores.slice(0, MAX_LEADERBOARD_ENTRIES);
                localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));
            } catch (e) { console.error("Could not save score to leaderboard:", e); }
        }

        function displayLeaderboard() {
            try {
                const scoresJSON = localStorage.getItem(LEADERBOARD_KEY); const scores = scoresJSON ? JSON.parse(scoresJSON) : [];
                leaderboardListElement.innerHTML = '';
                if (scores.length > 0) {
                    noScoresMessageElement.style.display = 'none';
                    scores.forEach(scoreItem => {
                        const li = document.createElement('li');
                        const nameSpan = document.createElement('span'); nameSpan.className = 'leaderboard-name'; nameSpan.textContent = scoreItem.name;
                        const scoreSpan = document.createElement('span'); scoreSpan.className = 'leaderboard-score'; scoreSpan.textContent = `${scoreItem.score} m`;
                        li.appendChild(nameSpan); li.appendChild(scoreSpan); leaderboardListElement.appendChild(li);
                    });
                } else noScoresMessageElement.style.display = 'block';
            } catch (e) {
                console.error("Could not display leaderboard:", e);
                leaderboardListElement.innerHTML = '<li>Error loading scores.</li>'; noScoresMessageElement.style.display = 'none';
            }
        }

        function updateDayCycleAndWeather(delta) {
            timeOfDay = 0.5; // Force daytime for performance

            const sunAngle = (timeOfDay - 0.25) * Math.PI * 2;
            let sunIntensity = Math.max(0, Math.sin(sunAngle));
            let nightFactor = 1.0 - sunIntensity;

            if (!ambientLight || !directionalLight || !scene.fog) return;
            ambientLight.intensity = 0.4 + sunIntensity * 0.6;
            directionalLight.intensity = 0.6 + sunIntensity * 1.2;
            directionalLight.position.y = 50 + sunIntensity * 50;

            if (lensflare) lensflare.visible = !reduceEnvironmentComplexityMobile && directionalLight.intensity > 0.1;

            const dayColor = new THREE.Color(0xa0d7e6);
            scene.background.copy(dayColor);
            scene.fog.color.copy(dayColor);

            const fogFactor = 1.0 - sunIntensity * 0.5;
            scene.fog.near = baseFogNear * (0.6 + fogFactor * 0.4);
            scene.fog.far = baseFogFar * (0.85 + fogFactor * 0.15);

            const isMobileDevice = reduceEnvironmentComplexityMobile;
            streetLights.forEach(sl => {
                sl.userData.fixture.material.emissiveIntensity = nightFactor * 1.5;
                sl.userData.light.intensity = isMobileDevice ? nightFactor * 0.2 : nightFactor * 3;
                sl.userData.light.visible = (nightFactor > 0.01);
            });

            if (headlightLeft) {
                let headLightBrightness = isRaining ? 0.8 : (nightFactor > 0.6 ? nightFactor * 1.5 : 0);
                headlightLeft.intensity = headLightBrightness; headlightRight.intensity = headLightBrightness;
                headlightLeft.visible = headLightBrightness > 0.01; headlightRight.visible = headLightBrightness > 0.01;

                const baseTaillightIntensity = 0.5;
                taillightLeft.intensity = baseTaillightIntensity + carVelocity*1.0;
                taillightRight.intensity = baseTaillightIntensity + carVelocity*1.0;
            }
            if(stars) stars.material.opacity = Math.max(0, nightFactor * 1.5 - 0.5);

            if (cloudMaterial) cloudMaterial.opacity = 0.3 + sunIntensity * 0.4;
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed * delta * 100;
                if (cloud.position.x > roadLength * 1.2 + 50) {
                    cloud.position.x = -roadLength*1.2-50; cloud.position.z = (Math.random()-0.5)*roadLength*1.5; cloud.position.y = Math.random()*20+40;
                }
            });

            // Rain Particle Update
            if (isRaining && gameHasStartedAfterCountdown) {
                if (road && road.material.roughness > 0.2) road.material.roughness -= 0.01;
                if (road && road.material.metalness < 0.4) road.material.metalness += 0.01;
                updateRainParticles_Instanced(delta); // Calls the instanced rain update
            } else {
                if (road && road.material.roughness < 0.8) road.material.roughness += 0.01;
                if (road && road.material.metalness > 0.1) road.material.metalness -= 0.01;
                if (rainInstanceMesh) rainInstanceMesh.visible = false; // Hide rain if not raining
            }

            if (currentPageId === 'game-page' && scene && scene.background) {
                const gamePageDiv = document.getElementById('game-page');
                if (gamePageDiv) gamePageDiv.style.backgroundColor = scene.background.getStyle();
            }
        }

        function updateEnemyAI(delta, worldMovementZ) {
            if (!enemyCar || !enemyCar.visible || !carModel || !gameHasStartedAfterCountdown) return;
            // Enemy car's Z position is already updated in objectsToScroll
            // const enemyActualSpeedOnRoad = baseDriveSpeed * enemyCarSpeedFactor;
            // enemyCar.position.z -= enemyActualSpeedOnRoad * delta * 60; // Normalize speed // Handled by objectsToScroll

            enemyLaneChangeTimer += delta * 1000;
            if (enemyLaneChangeTimer >= enemyLaneChangeInterval) {
                enemyLaneChangeTimer = 0;
                if (Math.random() < enemyLaneChangeProbability) enemyTargetX = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 4);
            }
            enemyCar.position.x = THREE.MathUtils.lerp(enemyCar.position.x, enemyTargetX, 0.03);
            if (enemyCar.position.z < carModel.position.z - 40) resetEnemyCar();
        }

        function playSound(soundName, loop = false, volume = null) {
            if (sounds[soundName] && typeof Audio !== "undefined" ) {
                sounds[soundName].loop = loop; const S = sounds[soundName];
                let baseVolume = soundName === 'engine' ? 0.3 : 0.5;
                S.volume = volume !== null ? volume * baseVolume : baseVolume;
                if ( (currentPageId === 'game-page' && !isGameOver && (!isCountingDown || !loop)) || !loop ) {
                    if (S.paused || !loop || S.currentTime > 0) {
                        const playPromise = S.play();
                        if (playPromise !== undefined) {
                            playPromise.catch(e => { /* console.warn('Audio play prevented:', e) */ });
                        }
                    }
                }
            }
        }

        function stopSound(soundName) {
            if (sounds[soundName] && typeof Audio !== "undefined") {
                sounds[soundName].pause(); sounds[soundName].currentTime = 0;
            }
        }

        function updateEngineSound() {
            if(sounds.engine && !isGameOver && currentPageId === 'game-page' && gameHasStartedAfterCountdown) {
                const minPlaybackRate = 0.5, maxPlaybackRate = 2.0;
                const targetPlaybackRate = minPlaybackRate + (carVelocity/maxSpeed * (maxPlaybackRate - minPlaybackRate));
                sounds.engine.playbackRate = THREE.MathUtils.lerp( sounds.engine.playbackRate || 1.0, targetPlaybackRate, 0.15 );
                const baseEngineVolume = 0.3, minVolume = 0.2, maxVolume = 0.8;
                const dynamicVolumeFactor = minVolume + (carVelocity/maxSpeed * (maxVolume - minVolume));
                let targetVolume = Math.min(baseEngineVolume * dynamicVolumeFactor, 1.0);
                sounds.engine.volume = THREE.MathUtils.lerp( sounds.engine.volume || baseEngineVolume, targetVolume, 0.1 );
                if (sounds.engine.paused && sounds.engine.volume > 0.01 && carVelocity > 0.01) {
                    const playPromise = sounds.engine.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(e => {/* console.warn('Engine sound play prevented:', e) */});
                    }
                }
            } else if (sounds.engine && (isGameOver || currentPageId !== 'game-page' || !gameHasStartedAfterCountdown)) {
                 stopSound('engine');
            }
        }

        // Initial page display
        showPage(currentPageId);
        const privacyPolicyPage = document.getElementById('privacy-policy-page');
        if (privacyPolicyPage) {
            const dateElement = privacyPolicyPage.querySelector('p strong');
            if (dateElement && dateElement.textContent.includes('[Current Date]')) {
                dateElement.textContent = `Last updated: ${new Date().toLocaleDateString()}`;
            }
        }

    </script>
</body>
</html>
