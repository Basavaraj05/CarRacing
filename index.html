<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gamezzz - Enter the World of Gamezzz - Play Now</title>

    <link rel="icon" type="image/png" sizes="32x32" href="./Images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./Images/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./Images/apple-touch-icon.png">
    <link rel="manifest" href="./Images/site.webmanifest">
    <meta name="theme-color" content="#162447">

    <style>
        /* Global Resets and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Add logo styles */
        .nav-logo {
            height: 40px;
            width: 40px; /* Make width equal to height for perfect circle */
            margin-right: 15px;
            border-radius: 50%; /* Make it perfectly round */
            object-fit: cover; /* Ensure the image covers the area properly */
            border: 2px solid #e43f5a; /* Add a border with the theme color */
            padding: 2px; /* Add some padding inside the border */
            background-color: white; /* Add white background */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Add subtle shadow */
        }

        .nav-title-container {
            display: flex;
            align-items: center;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            margin: 0;
            background-color: #1a1a2e;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overscroll-behavior: none;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            line-height: 1.6;
        }
        body.no-scroll-mobile {
            overflow: hidden;
        }


        canvas {
            display: block;
        }

        /* Ad Slot Placeholder Styling (for demonstration) */
        .ad-placeholder {
            width: 100%;
            margin: 20px auto;
            background: #2c2c44; /* Slightly different from page bg */
            border: 1px dashed #505070;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 0.9em;
            min-height: 50px; /* Minimum height for visibility */
        }
        .ad-placeholder-banner { max-width: 728px; height: 90px; }
        .ad-placeholder-box { max-width: 300px; height: 250px; }
        /* --- End Ad Slot Placeholder Styling --- */


        /* Navigation Bar */
        #main-nav {
            background-color: #162447;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 200;
            min-height: 60px;
            position: sticky;
            top: 0;
        }

        #main-nav .nav-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #f8f8f8;
            padding: 10px 0;
        }

        .hamburger-menu {
            display: none;
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
            z-index: 201; /* Above nav links container when open */
        }
        .hamburger-menu span {
            display: block;
            width: 25px;
            height: 3px;
            background-color: #e0e0e0;
            margin: 5px 0;
            transition: all 0.3s ease-in-out;
        }

        .nav-links-container {
            display: flex;
            align-items: center;
        }

        .nav-links-container a {
            color: #e0e0e0;
            text-decoration: none;
            padding: 12px 15px;
            margin-left: 5px;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
            font-weight: 500;
            white-space: nowrap;
        }

        .nav-links-container a:hover,
        .nav-links-container a.active {
            background-color: #e43f5a;
            color: #fff;
        }


        /* Page Container and Page Styles */
        .page-container {
            flex-grow: 1;
            position: relative;
            width: 100%;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .page {
            display: none;
            padding: 25px;
            animation: fadeIn 0.5s ease-in-out;
            min-height: calc(100vh - 60px);
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
        }
        .page.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .page h1, .page h2 {
            color: #e43f5a;
            margin-bottom: 25px;
        }
         .page h1 { font-size: 2em; }
         .page h2 { font-size: 1.6em; }

        .page p, .page ul {
            line-height: 1.7;
            max-width: 700px;
            margin-bottom: 18px;
            text-align: left;
            font-size: 1em;
        }
        .page ul {
            list-style-position: inside;
            padding-left: 10px;
        }
        .page ul li {
            margin-bottom: 10px;
        }

        /* Name Entry Page */
        #name-entry-page input[type="text"] {
            padding: 12px 15px;
            font-size: 1.1em;
            border-radius: 5px;
            border: 2px solid #1f4068;
            background-color: #e0e0e0;
            color: #1a1a2e;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }
         #name-entry-page input[type="text"]:focus {
            outline: none;
            border-color: #e43f5a;
            box-shadow: 0 0 8px rgba(228, 63, 90, 0.5);
        }

        .styled-button {
            padding: 12px 25px;
            font-size: 1.1em;
            color: white;
            background-color: #e43f5a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
            box-shadow: 0 4px #a32d40;
        }
        .styled-button:hover {
            background-color: #f5506e;
        }
        .styled-button:active {
            background-color: #d0304a;
            box-shadow: 0 2px #a32d40;
            transform: translateY(2px);
        }

        /* Game Page Specific */
        #game-page {
            padding: 0;
            overflow: hidden;
            background-color: #a0d7e6; /* Initial, will be updated by JS */
            touch-action: none; /* Important for mobile page-level gestures */
        }

        #loading-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #111; /* Slightly less dark to differentiate from potential black artifacts */
            color: white;
            display: flex; /* Changed from none to flex for initial visibility managed by JS */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.7s ease-out;
            text-align: center;
        }
        #loading-screen.hidden {
             opacity: 0;
             pointer-events: none;
        }
        #loading-progress {
            font-size: 0.6em;
            margin-top: 15px;
            color: #aaa;
        }

        #countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 6em; /* Large text */
            color: white;
            text-shadow: 2px 2px 8px black, 0 0 15px black;
            z-index: 1002;
            display: none;
            font-weight: bold;
            text-align: center;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 1px 1px 3px black, 0 0 5px black;
            z-index: 50;
            font-size: 1.3em;
        }
        #score { margin-bottom: 6px; font-weight: bold; }
        #distance { margin-bottom: 6px; font-weight: bold; }
        #speedometer { font-size: 0.85em; }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3333;
            font-size: 2.2em;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 6px black, 0 0 10px black;
            display: none;
            z-index: 101;
            padding: 20px;
            background-color: rgba(10,10,20,0.8);
            border-radius: 15px;
            flex-direction: column;
            align-items: center;
            width: 90%;
            max-width: 400px;
        }
        #game-over-title {
            margin-bottom: 15px;
        }
        #final-score-display {
            font-size: 0.55em;
            margin-bottom:15px;
            color: #fff;
        }
        #game-over button {
            display: block;
            margin-top: 12px;
            padding: 10px 20px;
            font-size: 0.48em;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
            width: 85%;
            max-width: 220px;
        }
        #restart-button { background-color: #4CAF50; box-shadow: 0 4px #388E3C; }
        #restart-button:active { background-color: #45a049; box-shadow: 0 2px #388E3C; transform: translateY(2px); }
        #view-leaderboard-button { background-color: #007bff; box-shadow: 0 4px #0056b3; }
        #view-leaderboard-button:active { background-color: #0069d9; box-shadow: 0 2px #0056b3; transform: translateY(2px); }
        #main-menu-button { background-color: #6c757d; box-shadow: 0 4px #545b62; }
        #main-menu-button:active { background-color: #5a6268; box-shadow: 0 2px #545b62; transform: translateY(2px); }


        .control-button {
            position: absolute;
            width: 70px;
            height: 70px;
            background-color: rgba(200, 200, 200, 0.45);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 60;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2em;
            color: rgba(0, 0, 0, 0.8);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s ease;
            touch-action: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .control-button:active {
            background-color: rgba(255, 255, 255, 0.65);
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        #left-button { 
            left: 25px; 
            bottom: 120px; 
        }

        #right-button { 
            right: 25px; 
            bottom: 120px; 
        }

        @media (max-width: 768px) {
            .control-button {
                width: 65px;
                height: 65px;
                font-size: 2em;
            }
            #left-button { 
                left: 20px; 
                bottom: 110px; 
            }
            #right-button { 
                right: 20px; 
                bottom: 110px; 
            }
        }

        @media (max-width: 480px) {
            .control-button {
                width: 60px;
                height: 60px;
                font-size: 1.8em;
            }
            #left-button { 
                left: 15px; 
                bottom: 100px; 
            }
            #right-button { 
                right: 15px; 
                bottom: 100px; 
            }
        }


        /* Leaderboard Page Styles */
        #leaderboard-page {
            background-color: #1a1a2e;
            color: #e0e0e0;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            padding: 25px;
            border-radius: 10px;
        }
        #leaderboard-page h2 {
            margin-bottom: 25px;
            color: #ffdd57;
            font-size: 1.8em;
        }
        #leaderboard-list {
            list-style-type: none;
            padding-left: 0;
            margin: 0 auto;
            width: 100%;
        }
        #leaderboard-list li {
            margin-bottom: 12px;
            font-size: 1em;
            text-align: left;
            border-bottom: 1px solid #1f4068;
            padding: 10px 8px;
            display: flex;
            justify-content: space-between;
            background-color: rgba(31, 64, 104, 0.2);
            border-radius: 5px;
        }
         #leaderboard-list li .leaderboard-name {
            font-weight: bold;
            color: #e0e0e0;
            margin-right: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #leaderboard-list li .leaderboard-score {
            color: #ffdd57;
            white-space: nowrap;
        }
        #leaderboard-list li:first-child {
            background-color: rgba(255, 221, 87, 0.15);
            border-left: 3px solid #ffdd57;
        }
        #leaderboard-list li:last-child { border-bottom: none; }

        #close-leaderboard-button {
            margin-top: 30px;
        }
        #no-scores-message {
            font-style: italic;
            color: #aaa;
            font-size: 1em;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) { /* Medium screens / Tablets */
            .nav-logo { height: 35px; width: 35px; }
            #main-nav .nav-title { font-size: 1.2em; }
            #main-nav { padding: 0 15px; }
            .hamburger-menu { display: block; }
            .nav-links-container {
                display: none; position: absolute; top: 60px; left: 0; right: 0;
                background-color: #162447; flex-direction: column; width: 100%;
                padding: 10px 0; box-shadow: 0 5px 10px rgba(0,0,0,0.2); z-index: 199;
            }
            .nav-links-container.open { display: flex; }
            .nav-links-container a {
                width: 100%; text-align: center; padding: 15px 20px; margin-left: 0;
                border-bottom: 1px solid rgba(255,255,255,0.1);
            }
            .nav-links-container a:last-child { border-bottom: none; }
            .hamburger-menu[aria-expanded="true"] span:nth-child(1) { transform: translateY(8px) rotate(45deg); }
            .hamburger-menu[aria-expanded="true"] span:nth-child(2) { opacity: 0; }
            .hamburger-menu[aria-expanded="true"] span:nth-child(3) { transform: translateY(-8px) rotate(-45deg); }

            .page { padding: 20px; }
            .page h1 { font-size: 1.8em; } .page h2 { font-size: 1.5em; }
            .page p, .page ul { font-size: 0.95em; }
            #ui-container { font-size: 1.1em; top: 8px; left: 8px; }
            #countdown-display { font-size: 5em; }


            .control-button {
                width: 60px; height: 60px; font-size: 1.9em;
            }
             #left-button { left: 15px; bottom: 110px; }
             #right-button { right: 15px; bottom: 110px; }


            #game-over { font-size: 1.8em; padding: 15px; }
            #game-over button { font-size: 0.5em; padding: 10px 15px; }
            .ad-placeholder-box { max-width: 100%; height: 200px; }
            #leaderboard-page h2 { font-size: 1.6em; }
            #leaderboard-list li { font-size: 0.95em; }
        }

        @media (max-width: 480px) { /* Small screens / Mobiles */
            .nav-logo { height: 30px; width: 30px; }
            #main-nav .nav-title { font-size: 1.1em; }
            .page { padding: 15px; }
            .page h1 { font-size: 1.6em; } .page h2 { font-size: 1.3em; }
            .page p, .page ul { font-size: 0.9em; }
            #name-entry-page input[type="text"] { font-size: 1em; }
            .styled-button { font-size: 1em; padding: 10px 20px; }
            #loading-screen { font-size: 1.8em; } #loading-progress { font-size: 0.5em; }
            #ui-container { font-size: 1em; }
            #countdown-display { font-size: 4em; }

            .control-button {
                width: 55px; height: 55px; font-size: 1.7em;
            }
             #left-button { left: 10px; bottom: 110px; }
             #right-button { right: 10px; bottom: 110px; }

            #game-over { font-size: 1.6em; }
            #final-score-display { font-size: 0.5em; }
            #game-over button { font-size: 0.45em; }
            .ad-placeholder-banner { height: 50px; }
            .ad-placeholder-box { height: 150px; }
            #leaderboard-page h2 { font-size: 1.4em; }
            #leaderboard-list li { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <nav id="main-nav">
        <div class="nav-title-container">
            <img src="./Images/logo1.png" alt="Gamezzz Logo" class="nav-logo">
            <div class="nav-title">Gamezzz</div>
        </div>
        <button class="hamburger-menu" aria-label="Toggle menu" aria-expanded="false">
            <span></span>
            <span></span>
            <span></span>
        </button>
        <div class="nav-links-container">
            <a href="#" data-page="name-entry-page">Play</a>
            <a href="#" data-page="leaderboard-page">Leaderboard</a>
            <a href="#" data-page="about-page">About</a>
            <a href="#" data-page="privacy-policy-page">Privacy Policy</a>
            <a href="#" data-page="contact-us-page">Contact Us</a>
        </div>
    </nav>

    <div class="page-container">
        <!-- Name Entry Page -->
        <div id="name-entry-page" class="page">
            <h1>Enter Your Name</h1>
            <input type="text" id="player-name-input" placeholder="Player Name" maxlength="15">
            <button id="start-game-button" class="styled-button">Start Game</button>
            <p style="margin-top: 20px; font-size: 0.9em; color: #bbb;">Enter your name to appear on the leaderboard!</p>
            <div id="ad-slot-name-entry" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
        </div>

        <!-- Game Page -->
        <div id="game-page" class="page">
            <div id="loading-screen"> <!-- Initially visible -->
                <div>LOADING ASSETS</div>
                <div id="loading-progress">0%</div>
            </div>
            <div id="countdown-display">3</div>
            <div id="container"></div>

            <div id="ui-container">
                <div id="score">Score: 0</div>
                <div id="distance">Distance: 0 m</div>
                <div id="speedometer">Speed: 0 km/h</div>
            </div>
            <div id="game-over">
                <div id="game-over-title">GAME OVER!</div>
                <div id="final-score-display"></div>
                <div id="ad-slot-game-over" class="ad-placeholder ad-placeholder-box">Ad Placeholder (e.g., Box Ad)</div>
                <button id="restart-button">Play Again</button>
                <button id="view-leaderboard-button">View Leaderboard</button>
                <button id="main-menu-button">Main Menu</button>
            </div>

            <div id="left-button" class="control-button">◀</div>
            <div id="right-button" class="control-button">▶</div>
        </div>

        <!-- Leaderboard Page -->
        <div id="leaderboard-page" class="page">
            <h2>High Scores</h2>
            <div id="ad-slot-leaderboard-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            <ol id="leaderboard-list"></ol>
            <div id="no-scores-message" style="display:none;">No high scores yet. Be the first!</div>
            <button id="close-leaderboard-button" class="styled-button">Back to Menu</button>
        </div>

        <!-- About Page -->
        <div id="about-page" class="page">
            <div>
                <h1>About 3D Racer</h1>
                <div id="ad-slot-about-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
                <p>Welcome to 3D Racer, an enhanced 3D car driving experience!</p>
                <p>This game is built using Three.js, a powerful 3D graphics library for the web. Drive as far as you can, collect points, and avoid crashing into other vehicles. Experience a dynamic day-night cycle and even occasional rain!</p>
                <p>Features:</p>
                <ul>
                    <li>Dynamic 3D environment with buildings, street lights, and traffic elements.</li>
                    <li>Realistic car physics simulation (basic).</li>
                    <li>Day-night cycle affecting lighting and visuals. (Currently forced daytime for performance)</li>
                    <li>Weather effects like rain (using InstancedMesh for performance).</li>
                    <li>Score and distance tracking.</li>
                    <li>Leaderboard to compete for the highest distance.</li>
                    <li>Touch controls for mobile (steering) and keyboard controls for desktop (steering).</li>
                    <li>Automatic acceleration after a countdown.</li>
                </ul>
                <p>This project is a demonstration of what can be achieved with modern web technologies. Have fun racing!</p>
                <div id="ad-slot-about-bottom" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            </div>
        </div>

        <!-- Privacy Policy Page -->
        <div id="privacy-policy-page" class="page">
            <div>
                <h1>Privacy Policy</h1>
                <div id="ad-slot-privacy-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
                <p><strong>Last updated: [Current Date]</strong></p>
                <p>This Privacy Policy describes Our policies and procedures on the collection, use and disclosure of Your information when You use the Service and tells You about Your privacy rights and how the law protects You.</p>

                <h2>1. Information We Collect</h2>
                <p>This game ("3D Racer") collects the following information:</p>
                <ul>
                    <li><strong>Player Name:</strong> If you choose to enter a name, it will be stored locally on your device in your browser's Local Storage to be displayed on the leaderboard. This name is not transmitted to any server by us.</li>
                    <li><strong>Game Scores (Distance):</strong> Your game scores (distance achieved) are stored locally on your device in your browser's Local Storage to maintain a local leaderboard. This data is not transmitted to any server by us.</li>
                </ul>

                <h2>2. How We Use Your Information</h2>
                <p>The information collected is used solely for the following purposes:</p>
                <ul>
                    <li>To display your name and score on the in-game leaderboard, which is local to your browser.</li>
                    <li>To allow you to track your high scores over time.</li>
                </ul>

                <h2>3. Data Storage and Security</h2>
                <p>All data (player name and scores) is stored in your web browser's Local Storage. We do not have access to this data, nor is it transmitted to any external servers. The security of this data depends on the security of your own device and browser.</p>

                <h2>4. Third-Party Services</h2>
                <p>This game uses assets (like 3D models, sounds, and JavaScript libraries) hosted on third-party services (e.g., unpkg.com, threejs.org, mixkit.co, gstatic.com). These services may have their own privacy policies and may collect data according to their terms. We are not responsible for the privacy practices of these third-party services.</p>

                <h2>5. Children's Privacy</h2>
                <p>Our Service does not address anyone under the age of 13. We do not knowingly collect personally identifiable information from anyone under the age of 13. If you are a parent or guardian and You are aware that Your child has provided Us with Personal Data without your consent, please contact Us. If We become aware that We have collected Personal Data from anyone under the
13 without verification of parental consent, We take steps to remove that information from Our servers (though in this game's case, it's local storage, which you can clear via browser settings).</p>

                <h2>6. Changes to This Privacy Policy</h2>
                <p>We may update Our Privacy Policy from time to time. We will notify You of any changes by posting the new Privacy Policy on this page.</p>
                <p>You are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are effective when they are posted on this page.</p>

                <h2>7. Contact Us</h2>
                <p>If you have any questions about this Privacy Policy, You can contact us: [Provide a placeholder email or contact method, e.g., by email: contact@example.com]</p>
                <div id="ad-slot-privacy-bottom" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            </div>
        </div>

        <!-- Contact Us Page -->
        <div id="contact-us-page" class="page">
            <div>
                <h1>Contact Us</h1>
                <div id="ad-slot-contact-top" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
                <p>If you have any questions, feedback, or inquiries about the 3D Racer game, please feel free to reach out.</p>
                <p><strong>Email:</strong> <a href="mailto:feedback@example.com" style="color: #e43f5a;">feedback@example.com</a> (This is a placeholder email)</p>
                <p><strong>GitHub/Project Page:</strong> (If applicable, link to your project repository or website here)</p>
                <p>We appreciate your interest and will do our best to respond in a timely manner.</p>
                <div id="ad-slot-contact-bottom" class="ad-placeholder ad-placeholder-banner">Ad Placeholder (e.g., Banner)</div>
            </div>
        </div>
    </div>

    <!-- stats.js, if you want to include it locally or from a CDN -->
    <script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>

     <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

        // --- Performance Monitoring ---
        let stats;

        // --- Page Navigation and State ---
        const pages = document.querySelectorAll('.page');
        const mainNav = document.getElementById('main-nav');
        const navLinksFromContainer = document.querySelectorAll('.nav-links-container a[data-page]');
        const pageContainer = document.querySelector('.page-container');
        let currentPageId = 'name-entry-page';
        let currentPlayerName = localStorage.getItem('3DRacerPlayerName') || "Player";
        let gameInitialized = false;
        let assetsCurrentlyLoading = false;

        const playerNameInput = document.getElementById('player-name-input');
        const startGameButton = document.getElementById('start-game-button');

        const hamburger = document.querySelector('.hamburger-menu');
        const navLinksContainer = document.querySelector('.nav-links-container');

        playerNameInput.value = currentPlayerName === "Player" ? "" : currentPlayerName;

        function handleAdSlotVisibility(slotId) {
            // const adSlot = document.getElementById(slotId);
            // if (adSlot) { console.log(`Ad slot ${slotId} is now visible.`); }
        }

        function showPage(pageId) {
            const gamePage = document.getElementById('game-page');
            const oldPageId = currentPageId;

            if (pageId === 'game-page') {
                document.body.style.overflow = 'hidden';
                pageContainer.style.overflowY = 'hidden';
                if (gamePage) gamePage.style.touchAction = 'none'; 
                if (stats) stats.dom.style.display = 'block';
            } else {
                document.body.style.overflow = 'auto';
                pageContainer.style.overflowY = 'auto';
                if (gamePage) gamePage.style.touchAction = 'auto';
                if (stats) stats.dom.style.display = 'none';

                if (oldPageId === 'game-page') {
                     if (sounds.engine) stopSound('engine');
                     if (sounds.rain) stopSound('rain');
                     if (countdownInterval) {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        if(countdownDisplayElement) countdownDisplayElement.style.display = 'none';
                        isCountingDown = false;
                    }
                }
            }

            pages.forEach(page => {
                if (page.id === pageId) {
                    page.classList.add('active');
                    const adSlotsOnPage = page.querySelectorAll('.ad-placeholder[id]');
                    adSlotsOnPage.forEach(slot => handleAdSlotVisibility(slot.id));
                } else {
                    page.classList.remove('active');
                }
            });
            navLinksFromContainer.forEach(link => {
                link.classList.toggle('active', link.dataset.page === pageId);
            });

            currentPageId = pageId;

            if (pageId === 'game-page') {
                if (!gameInitialized && !assetsCurrentlyLoading) {
                    assetsCurrentlyLoading = true;
                    console.log("Starting initial game and asset loading...");
                    initThreeJSGame();
                } else if (gameInitialized) {
                    console.log("Game already initialized, restarting game logic.");
                    restartGame();
                }
            }

            if (pageId === 'leaderboard-page') displayLeaderboard();
            if (pageId === 'game-over') handleAdSlotVisibility('ad-slot-game-over');
            window.scrollTo(0, 0);
        }

        navLinksFromContainer.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageIdToLoad = link.dataset.page;
                showPage(pageIdToLoad);

                if (navLinksContainer.classList.contains('open')) {
                    hamburger.setAttribute('aria-expanded', 'false');
                    navLinksContainer.classList.remove('open');
                    document.body.classList.remove('no-scroll-mobile');
                }
            });
        });

        startGameButton.addEventListener('click', () => {
            const name = playerNameInput.value.trim();
            currentPlayerName = name || "Player";
            localStorage.setItem('3DRacerPlayerName', currentPlayerName);
            showPage('game-page');
        });


        hamburger.addEventListener('click', () => {
            const isExpanded = hamburger.getAttribute('aria-expanded') === 'true';
            hamburger.setAttribute('aria-expanded', String(!isExpanded));
            navLinksContainer.classList.toggle('open');
            document.body.classList.toggle('no-scroll-mobile', !isExpanded);
        });

        // --- Game Variables ---
        let scene, camera, renderer, carModel, enemyCar, clock;
        let ambientLight, directionalLight, lensflare;
        let road, kerbs = [];
        let buildings = [], streetLights = [], trafficLights = [];
        let clouds = [];
        let cloudMaterial;
        let stars = null;
        const numStarsBase = 300; // Base for desktop

        const roadWidth = 10;
        const roadLength = 200; 
        const buildingSpacingBase = 15;
        const lightSpacingBase = 30;

        let effectiveNumBuildings, effectiveNumLights, effectiveNumClouds, effectiveNumStars;
        let reduceEnvironmentComplexityMobile = false;

        const kerbHeight = 0.2; const kerbWidth = 0.3; const enemyCarSpeedFactor = 0.65;

        let carVelocity = 0;
        let carAcceleration = 0.005; 
        let carDeceleration = 0.002;
        let maxSpeed = 1.0;          
        let currentDisplaySpeed = 0;
        const baseDriveSpeed = 0.8;

        // Instanced Mesh variables
        let roadLineInstanceMesh;
        const MAX_ROAD_LINES = Math.floor(roadLength / (3 + 5)) + 10; 

        let rainInstanceMesh, rainInstanceData = [];
        const ABSOLUTE_MAX_RAIN_PARTICLES = 150;
        let effectiveMaxRainParticles;

        let exhaustInstanceMesh, exhaustInstanceData = [];
        const ABSOLUTE_MAX_EXHAUST_PARTICLES = 25;
        let effectiveMaxExhaustParticles;

        let skidInstanceMesh, skidInstanceData = [];
        const ABSOLUTE_MAX_SKID_MARKS = 40;
        let effectiveMaxSkidMarks;
        let nextSkidMarkIndex = 0;
        let lastSkidTime = 0; const skidInterval = 120; 

        let isRaining = false;
        let timeOfDay = 0.5; // Forced daytime for performance
        let baseFogNear = roadLength * 0.4; let baseFogFar = roadLength * 0.9;

        const sounds = {};
        if (typeof Audio !== "undefined") {
            sounds.engine = new Audio('./sound effect/11L-Generate_a_racing_ca-1746887375438.mp3');
            // sounds.collect = new Audio('./sound effect/collect.mp3');
            // sounds.skid = new Audio('./sound effect/skid.mp3');
            // sounds.nearMiss = new Audio('./sound effect/nearMiss.mp3');
            // sounds.rain = new Audio('./sound effect/rain.mp3');
            if (sounds.engine) sounds.engine.addEventListener('error', (e) => console.error('Error loading engine sound:', e));
            Object.values(sounds).filter(s => s).forEach(sound => sound.volume = 0.5);
            if(sounds.engine) sounds.engine.volume = 0.3;
        }

        let enemyTargetX = 0; let enemyLaneChangeTimer = 0; const enemyLaneChangeInterval = 1500; const enemyLaneChangeProbability = 0.5;
        let moveLeft = false; let moveRight = false;
        let gameHasStartedAfterCountdown = false;
        let isCountingDown = false;
        let countdownValue = 3;
        let countdownInterval = null;

        const carTurnSpeed = 0.18; let carBaseY = 0.5; let carCurrentYOffset = 0;
        const suspensionStiffness = 0.2; const suspensionDamping = 0.15; let suspensionVelocity = 0;
        let score = 0; let distanceTraveled = 0; let isGameOver = false; let nearMissCooldown = 0; const nearMissBonus = 5;
        const points = []; const numPoints = 10; const pointValue = 10;
        let pointGeometry, pointMaterial; const pointRadius = 0.35;
        let coinPatterns = ['left', 'right', 'middle']; let currentPatternIndex = 0; let coinsInCurrentPattern = 0; let targetCoinsForPattern = 5 + Math.floor(Math.random() * 3);

        const scoreElement = document.getElementById('score');
        const distanceElement = document.getElementById('distance');
        const speedometerElement = document.getElementById('speedometer');
        const gameOverElement = document.getElementById('game-over');
        const finalScoreDisplayElement = document.getElementById('final-score-display');
        const restartButton = document.getElementById('restart-button');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingProgressElement = document.getElementById('loading-progress');
        const leaderboardListElement = document.getElementById('leaderboard-list');
        const noScoresMessageElement = document.getElementById('no-scores-message');
        const closeLeaderboardButton = document.getElementById('close-leaderboard-button');
        const viewLeaderboardButton = document.getElementById('view-leaderboard-button');
        const mainMenuButton = document.getElementById('main-menu-button');
        const countdownDisplayElement = document.getElementById('countdown-display');

        const LEADERBOARD_KEY = 'carGameLeaderboard_Daytime_v3_Named'; const MAX_LEADERBOARD_ENTRIES = 10;
        let playerBox = new THREE.Box3(); let enemyBox = new THREE.Box3(); let pointBox = new THREE.Box3();
        let playerSize = new THREE.Vector3(); let enemySize = new THREE.Vector3();
        const baseFov = 70;

        const GAP_AFTER_LOADING_MS = 700;

        // UI Update Throttling
        let lastUiUpdateTime = 0;
        const UI_UPDATE_INTERVAL = 100; // milliseconds (10 times per second)

        // Three.js Helpers for matrix operations
        const _tempMatrix = new THREE.Matrix4();
        const _tempVector3 = new THREE.Vector3();
        const _tempQuaternion = new THREE.Quaternion();
        const _tempEuler = new THREE.Euler();
        const _tempObject = new THREE.Object3D();


        const loadingManager = new THREE.LoadingManager();
        loadingManager.onStart = (url, itemsLoaded, itemsTotal) => {
            console.log(`Loading started. Total items: ${itemsTotal}`);
            assetsCurrentlyLoading = true;
            loadingScreen.classList.remove('hidden');
            loadingProgressElement.textContent = `0%`;
        };
        loadingManager.onLoad = () => {
            console.log("All assets loaded by LoadingManager.");
            assetsCurrentlyLoading = false;

            if(renderer && scene && camera) {
                 try {
                    renderer.render(scene, camera);
                    console.log("Rendered one frame after asset load.");
                } catch (e) {
                    console.error("Error rendering frame after load:", e);
                }
            } else {
                 console.warn("Renderer, scene or camera not ready for post-load render.");
            }

            setTimeout(() => {
                console.log("Gap after loading finished. Hiding loading screen and starting countdown.");
                loadingScreen.classList.add('hidden');
                gameInitialized = true;

                if (currentPageId === 'game-page' && !isGameOver && !isCountingDown) {
                    initiateCountdown();
                } else {
                    console.log("Not on game page, or game over, or already counting down. No countdown initiated from loadingManager.");
                }
            }, GAP_AFTER_LOADING_MS);
        };
        loadingManager.onError = (url) => {
            console.error(`Error loading ${url}. Asset loading might be incomplete.`);
            assetsCurrentlyLoading = false;
            loadingProgressElement.textContent = `Error loading assets.`;
        };
        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
            const progress = Math.round((itemsLoaded / itemsTotal) * 100);
            loadingProgressElement.textContent = `${progress}%`;
        };

        let headlightLeft, headlightRight, taillightLeft, taillightRight;

        function updatePerformanceSettings() {
            const isMobileDevice = window.innerWidth <= 768;
            reduceEnvironmentComplexityMobile = isMobileDevice;

            if (renderer) {
                // OPTIMIZATION: Adjust pixel ratio for mobile
                const pixelRatio = Math.min(window.devicePixelRatio, isMobileDevice ? 1.2 : 2.0); // Was 1.5 for mobile
                renderer.setPixelRatio(pixelRatio);
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                // Shadows enabled/type set in initThreeJSGame and here for consistency
                renderer.shadowMap.enabled = true; 
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            if (directionalLight && directionalLight.shadow) {
                const shadowMapSize = isMobileDevice ? 512 : 1024; // 512 is a good compromise for mobile
                if (directionalLight.shadow.mapSize.width !== shadowMapSize) {
                    directionalLight.shadow.mapSize.width = shadowMapSize;
                    directionalLight.shadow.mapSize.height = shadowMapSize;
                    if (directionalLight.shadow.map) {
                        directionalLight.shadow.map.dispose();
                        directionalLight.shadow.map = null;
                    }
                }
                // OPTIMIZATION: Tighter shadow frustum and shorter shadow distance for mobile
                directionalLight.shadow.camera.far = reduceEnvironmentComplexityMobile ? 120 : 180;
                const frustumSizeFactor = reduceEnvironmentComplexityMobile ? 0.18 : 0.25;
                directionalLight.shadow.camera.left = -roadLength * frustumSizeFactor;
                directionalLight.shadow.camera.right = roadLength * frustumSizeFactor;
                directionalLight.shadow.camera.top = roadLength * frustumSizeFactor;
                directionalLight.shadow.camera.bottom = -roadLength * frustumSizeFactor;
                directionalLight.shadow.camera.updateProjectionMatrix();
            }

            // OPTIMIZATION: Adjust environment complexity more aggressively for mobile
            if (reduceEnvironmentComplexityMobile) {
                effectiveNumBuildings = Math.floor(roadLength / (buildingSpacingBase * 2.5)); // Was 1.5 or 2.0
                effectiveNumLights = Math.floor(roadLength / (lightSpacingBase * 2.5));    // Was 1.5 or 2.0
                effectiveNumClouds = 6; // Was 8
                effectiveNumStars = 80; // Was 100
            } else {
                effectiveNumBuildings = Math.floor(roadLength / buildingSpacingBase);
                effectiveNumLights = Math.floor(roadLength / lightSpacingBase);
                effectiveNumClouds = 20;
                effectiveNumStars = numStarsBase;
            }

            // OPTIMIZATION: Effective particle counts
            effectiveMaxRainParticles = reduceEnvironmentComplexityMobile ? 60 : ABSOLUTE_MAX_RAIN_PARTICLES;
            effectiveMaxExhaustParticles = reduceEnvironmentComplexityMobile ? 15 : ABSOLUTE_MAX_EXHAUST_PARTICLES;
            effectiveMaxSkidMarks = reduceEnvironmentComplexityMobile ? 25 : ABSOLUTE_MAX_SKID_MARKS;
            
            // If createEnvironmentAssets is called after this, it will use new effectiveNums.
            // If particle systems are created after this, they will use new effectiveMax...
            // However, existing InstancedMeshes for particles are created with ABSOLUTE_MAX counts.
            // The update loops for particles will respect 'effectiveMax...' for active particles.
        }

        function createWindowTexture(baseColorHex, buildingWidth, buildingHeight) {
            const canvas = document.createElement('canvas');
            // OPTIMIZATION: Drastically reduce canvas texture size for mobile buildings
            const S = reduceEnvironmentComplexityMobile ? 32 : 128; // Was 48:128
            canvas.width = S; canvas.height = S * 1.5; // Maintain aspect ratio
            const ctx = canvas.getContext('2d');
            const baseColorStr = new THREE.Color(baseColorHex).getStyle();
            ctx.fillStyle = baseColorStr; ctx.fillRect(0, 0, canvas.width, canvas.height);

            const N_col = reduceEnvironmentComplexityMobile ? 1 : 3; // Keep as is, 1 col on mobile is fine
            const N_row = reduceEnvironmentComplexityMobile ? 2 : 5; // Keep as is
            const cellWidth = canvas.width / N_col; const cellHeight = canvas.height / N_row;
            const windowPadWidth = cellWidth * 0.15; const windowPadHeight = cellHeight * 0.12;
            const windowWidth = cellWidth - 2 * windowPadWidth; const windowHeight = cellHeight - 2 * windowPadHeight;
            for (let r = 0; r < N_row; r++) {
                for (let c = 0; c < N_col; c++) {
                    if (Math.random() > 0.1) { // 10% chance of no window in a cell
                        // Simulate lit/unlit windows (subtle, as it's forced daytime)
                        let currentWindowColor = (Math.random() > 0.3) ? '#252a30' : '#4a5058'; // Darker, less yellow
                        if (timeOfDay < 0.2 || timeOfDay > 0.8) { // If it were night
                           currentWindowColor = (Math.random() > 0.4) ? '#FFFF99' : '#354048'; // Some lit
                        }
                        ctx.fillStyle = currentWindowColor;
                        ctx.fillRect(c * cellWidth + windowPadWidth, r * cellHeight + windowPadHeight, windowWidth, windowHeight);
                    }
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            if (renderer) texture.anisotropy = renderer.capabilities.getMaxAnisotropy() / (reduceEnvironmentComplexityMobile ? 2 : 1);
            // OPTIMIZATION: Stretch texture more on mobile to use smaller source texture
            const metersPerTileWidth = reduceEnvironmentComplexityMobile ? 5 : 4; 
            const metersPerTileHeight = reduceEnvironmentComplexityMobile ? 6 : 5;
            texture.repeat.set(buildingWidth / metersPerTileWidth, buildingHeight / metersPerTileHeight);
            texture.needsUpdate = true;
            return texture;
        }

        function initThreeJSGame() {
            console.log("initThreeJSGame called.");
            loadingScreen.classList.remove('hidden');
            loadingProgressElement.textContent = `0%`;

            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0d7e6); // Initial color
            scene.fog = new THREE.Fog(0xa0d7e6, baseFogNear, baseFogFar); // Initial fog

            camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth / window.innerHeight, 0.1, 1000);

            stats = new Stats();
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '70px';
            stats.dom.style.left = '10px';
            stats.dom.style.display = 'none';
            document.body.appendChild(stats.dom);

            try {
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, // Kept true as per request
                    alpha: true,
                    powerPreference: "high-performance"
                });
                // Call updatePerformanceSettings early to set pixelRatio, shadow map size etc.
                updatePerformanceSettings(); // Sets pixelRatio, shadow map size for renderer and light

                // renderer.setSize is already called within updatePerformanceSettings
                // renderer.shadowMap.enabled and type also set within updatePerformanceSettings via renderer check
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2; 
                const container = document.getElementById('container');
                container.innerHTML = '';
                container.appendChild(renderer.domElement);
            } catch (e) {
                console.error("Error initializing WebGL Renderer:", e);
                loadingProgressElement.textContent = "Error: WebGL not supported or failed to initialize.";
                assetsCurrentlyLoading = false;
                return;
            }

            ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Initial intensity
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Initial intensity
            directionalLight.position.set(50, 100, 20); // Default position
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.5;
            // Shadow frustum and map size are now set in updatePerformanceSettings
            // If updatePerformanceSettings was called before light creation, call it again or apply settings here
            // It's cleaner if updatePerformanceSettings can handle pre-existing objects if any
            if (directionalLight.shadow) { // Ensure shadow object exists
                const shadowMapSize = reduceEnvironmentComplexityMobile ? 512 : 1024;
                directionalLight.shadow.mapSize.width = shadowMapSize;
                directionalLight.shadow.mapSize.height = shadowMapSize;
                directionalLight.shadow.camera.far = reduceEnvironmentComplexityMobile ? 120 : 180;
                const frustumSizeFactor = reduceEnvironmentComplexityMobile ? 0.18 : 0.25;
                directionalLight.shadow.camera.left = -roadLength * frustumSizeFactor;
                directionalLight.shadow.camera.right = roadLength * frustumSizeFactor;
                directionalLight.shadow.camera.top = roadLength * frustumSizeFactor;
                directionalLight.shadow.camera.bottom = -roadLength * frustumSizeFactor;
            }
            scene.add(directionalLight);


            const textureLoader = new THREE.TextureLoader(loadingManager);
            if (!reduceEnvironmentComplexityMobile) { // Lensflare only on non-mobile
                try {
                    const textureFlare0 = textureLoader.load("https://threejs.org/examples/textures/lensflare/lensflare0.png");
                    const textureFlare3 = textureLoader.load("https://threejs.org/examples/textures/lensflare/lensflare3.png");
                    lensflare = new Lensflare();
                    lensflare.addElement(new LensflareElement(textureFlare0, 700, 0, directionalLight.color));
                    lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
                    lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
                    lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
                    lensflare.addElement(new LensflareElement(textureFlare3, 70, 1.0));
                    directionalLight.add(lensflare);
                } catch (e) {
                    console.warn("Could not load lensflare textures:", e);
                    lensflare = null;
                }
            } else {
                lensflare = null;
            }

            const groundGeo = new THREE.PlaneGeometry(roadLength * 2, roadLength);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a7936, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2; ground.position.y = -0.05;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadGeo = new THREE.PlaneGeometry(roadWidth, roadLength);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8, metalness: 0.1 });
            road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2; road.position.y = 0;
            road.receiveShadow = true;
            scene.add(road);

            const lineLength = 3; const lineGap = 5;
            const numRoadLinesToCreate = Math.floor(roadLength / (lineLength + lineGap)) + 10; 
            const lineGeo = new THREE.PlaneGeometry(0.25, lineLength);
            const lineMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            roadLineInstanceMesh = new THREE.InstancedMesh(lineGeo, lineMat, numRoadLinesToCreate);
            roadLineInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            const lineDummy = new THREE.Object3D();
            lineDummy.rotation.x = -Math.PI / 2;
            lineDummy.position.y = 0.0051; 
            for (let i = 0; i < numRoadLinesToCreate; i++) {
                lineDummy.position.z = (roadLength / 2) - (lineLength / 2) - i * (lineLength + lineGap);
                lineDummy.updateMatrix();
                roadLineInstanceMesh.setMatrixAt(i, lineDummy.matrix);
            }
            roadLineInstanceMesh.instanceMatrix.needsUpdate = true;
            scene.add(roadLineInstanceMesh);


            const kerbTexture = createKerbTexture();
            kerbTexture.wrapS = THREE.RepeatWrapping; kerbTexture.repeat.set(roadLength / 5, 1);
            const kerbGeo = new THREE.BoxGeometry(kerbWidth, kerbHeight, roadLength);
            const kerbMat = new THREE.MeshStandardMaterial({ map: kerbTexture, roughness: 0.7 });
            kerbs = [];
            [-1, 1].forEach(side => {
                const kerb = new THREE.Mesh(kerbGeo, kerbMat.clone()); // Clone material if it has unique properties like map offset
                kerb.position.set(side * (roadWidth / 2 + kerbWidth / 2), kerbHeight / 2, 0);
                kerb.castShadow = false; // Kerbs generally don't need to cast shadows
                kerb.receiveShadow = true;
                kerbs.push(kerb); scene.add(kerb);
            });

            cloudMaterial = new THREE.MeshBasicMaterial({ // Basic material for clouds is cheaper
                color: 0xffffff, transparent: true, opacity: 0.6, depthWrite: false
            });

            createEnvironmentAssets(); // Create buildings, lights, clouds, stars using effectiveNum...

            // OPTIMIZATION: Simpler point geometry for mobile
            pointGeometry = new THREE.SphereGeometry(pointRadius, reduceEnvironmentComplexityMobile ? 6 : 12, reduceEnvironmentComplexityMobile ? 4 : 8);
            pointMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0xeeaa00, emissiveIntensity: 0.7, roughness: 0.3 });
            points.length = 0; // Clear if re-initializing
            for (let i = 0; i < numPoints; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial.clone()); // Clone material for potential individual changes
                point.castShadow = false; point.receiveShadow = false; // Points don't need shadows
                points.push(point);
                resetPointPosition(point, true); // Initial placement
                scene.add(point);
            }

            createRainParticleSystem_Instanced();
            createExhaustParticleSystem_Instanced();
            createSkidMarkSystem_Instanced();

            loadCarModels();

            window.addEventListener('resize', onWindowResize, false);
            restartButton.addEventListener('click', restartGame);
            viewLeaderboardButton.addEventListener('click', () => { gameOverElement.style.display = 'none'; showPage('leaderboard-page'); });
            mainMenuButton.addEventListener('click', () => { gameOverElement.style.display = 'none'; showPage('name-entry-page'); });
            closeLeaderboardButton.addEventListener('click', () => showPage('name-entry-page'));

            setupControls();
            updateScoreDisplay(); updateDistanceDisplay(); updateSpeedometer();
            updateDayCycleAndWeather(0); // Initial call
            animate();
        }

        function createKerbTexture() {
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 32; const stripeWidth = 16; const colors = ['#dd0000', '#eeeeee'];
            for (let i = 0; i < canvas.width / stripeWidth; i++) { ctx.fillStyle = colors[i % 2]; ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvas.height); }
            const texture = new THREE.CanvasTexture(canvas);
            if (renderer) texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.needsUpdate = true;
            return texture;
        }

        function createEnvironmentAssets() {
            const buildingBaseColors = [ 0xaaaaaa, 0x888890, 0x999080, 0x777777, 0x605550, 0xacb2b7, 0xb5a89a, 0x5a6469 ];
            function createBuilding() {
                const height = Math.random() * 25 + 15; const width = Math.random() * 6 + 5; const depth = Math.random() * 6 + 5;
                const buildingGeo = new THREE.BoxGeometry(width, height, depth); // Box is cheap
                const selectedBaseColorHex = buildingBaseColors[Math.floor(Math.random() * buildingBaseColors.length)];
                const wallTexture = createWindowTexture(selectedBaseColorHex, width, height);
                const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.6 + Math.random() * 0.3, metalness: Math.random() * 0.1, color: 0xffffff });
                const roofColor = new THREE.Color(selectedBaseColorHex).multiplyScalar(0.8);
                const roofMaterial = new THREE.MeshStandardMaterial({ color: roofColor, roughness: 0.8, metalness: 0.1 });
                const building = new THREE.Mesh(buildingGeo, [wallMaterial, wallMaterial, roofMaterial, roofMaterial, wallMaterial, wallMaterial]);
                building.position.y = height / 2 - 0.04; // Align base with ground
                // OPTIMIZATION: Buildings don't cast shadows on mobile
                building.castShadow = !reduceEnvironmentComplexityMobile; 
                building.receiveShadow = true; 
                return building;
            }
            buildings.forEach(b => { if (b.parent) b.parent.remove(b); b.geometry.dispose(); b.material.forEach(m => m.dispose()); }); // Clear old
            buildings = [];
            for (let i = 0; i < effectiveNumBuildings; i++) {
                [-1, 1].forEach(side => {
                    const building = createBuilding();
                    const currentBuildingSpacing = buildingSpacingBase * (reduceEnvironmentComplexityMobile ? 2.5 : 1.0);
                    const zPos = (roadLength / 2) - (currentBuildingSpacing / 2) - i * currentBuildingSpacing + (Math.random()-0.5) * currentBuildingSpacing * 0.5;
                    const xOffset = roadWidth / 2 + kerbWidth + 2 + Math.random() * 8 + building.geometry.parameters.width / 2;
                    building.position.set(side * xOffset, building.position.y, zPos);
                    buildings.push(building); scene.add(building);
                });
            }

            function createStreetLight() {
                const group = new THREE.Group(); 
                const poleHeight = 7; const poleRadius = 0.1; 
                // OPTIMIZATION: Simpler cylinder for pole on mobile
                const poleGeo = new THREE.CylinderGeometry(poleRadius, poleRadius * 1.2, poleHeight, reduceEnvironmentComplexityMobile? 5:8); 
                const poleMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.9, roughness: 0.3 }); const pole = new THREE.Mesh(poleGeo, poleMat);
                // OPTIMIZATION: Streetlight poles don't cast shadows on mobile
                pole.castShadow = !reduceEnvironmentComplexityMobile; 
                pole.position.y = poleHeight/2; group.add(pole);
                
                const armLength = 1.5; const armGeo = new THREE.BoxGeometry(armLength, poleRadius * 1.8, poleRadius * 1.8); const arm = new THREE.Mesh(armGeo, poleMat);
                arm.castShadow = !reduceEnvironmentComplexityMobile; // Arm either
                arm.position.set(0, poleHeight - poleRadius * 2.5, 0); group.add(arm);
                
                // OPTIMIZATION: Simpler sphere for fixture on mobile
                const lightFixtureGeo = new THREE.SphereGeometry(poleRadius * 2.5, reduceEnvironmentComplexityMobile ? 5 : 16, reduceEnvironmentComplexityMobile ? 3 : 8); 
                const lightFixtureMat = new THREE.MeshStandardMaterial({ color: 0xffffdd, emissive: 0xffffaa, emissiveIntensity: 0 });  const lightFixture = new THREE.Mesh(lightFixtureGeo, lightFixtureMat);
                lightFixture.castShadow = false; // Fixture itself doesn't cast shadow
                lightFixture.position.set(0, poleHeight - poleRadius * 2.5, 0); group.add(lightFixture);
                
                const pointLight = new THREE.PointLight(0xffffee, 0, 15, 1.5); // Intensity 0 initially, distance 15, decay 1.5
                pointLight.castShadow = false; // Streetlights' point lights do not cast shadows (VERY important for perf)
                pointLight.visible = false; // Initially off
                lightFixture.add(pointLight); // Add to fixture so it moves with it
                group.userData = { armLength: armLength, fixture: lightFixture, light: pointLight }; return group;
            }
            streetLights.forEach(sl => { if (sl.parent) sl.parent.remove(sl); sl.traverse(o => {if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose();})}); // Clear old
            streetLights = [];
            for (let i = 0; i < effectiveNumLights; i++) {
                const zPos = (roadLength / 2) - (lightSpacingBase / 2) - i * lightSpacingBase + (Math.random()-0.5) * lightSpacingBase * 0.5;
                [-1, 1].forEach(side => {
                    const light = createStreetLight();
                    const xPos = roadWidth / 2 + kerbWidth + 1.0;
                    light.position.set(side * xPos, 0, zPos);
                    light.rotation.y = side > 0 ? -Math.PI / 2.5 : Math.PI / 2.5; // Angle arm over road
                    light.children[1].position.x = -light.userData.armLength / 2; // Adjust arm mesh position
                    light.children[2].position.x = -light.userData.armLength; // Adjust fixture mesh position
                    streetLights.push(light); scene.add(light);
                });
            }

            trafficLights.forEach(tl => { if (tl.parent) tl.parent.remove(tl);}); // Clear old if any
            trafficLights = []; // Not implemented visually yet

            clouds.forEach(c => { if (c.parent) c.parent.remove(c); c.traverse(o => {if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose();}) }); // Clear old
            clouds = [];
            for (let i = 0; i < effectiveNumClouds; i++) {
                const cloudGroup = new THREE.Group();
                const numSpheres = reduceEnvironmentComplexityMobile ? (Math.floor(Math.random() * 2) + 1) : (Math.floor(Math.random() * 5) + 3); // Fewer spheres for mobile clouds
                for(let j=0; j < numSpheres; j++) {
                    const size = Math.random() * 5 + 3;
                    // OPTIMIZATION: Simpler sphere geometry for cloud parts on mobile
                    const cloudPartGeo = new THREE.SphereGeometry(size, reduceEnvironmentComplexityMobile ? 5:8, reduceEnvironmentComplexityMobile ? 3:6);
                    const cloudPart = new THREE.Mesh(cloudPartGeo, cloudMaterial.clone()); 
                    cloudPart.position.set( (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 3 );
                    cloudGroup.add(cloudPart);
                }
                cloudGroup.position.set( (Math.random() - 0.5) * roadLength * 1.5, Math.random() * 20 + 40, (Math.random() - 0.5) * roadLength * 1.5 );
                cloudGroup.userData.speed = Math.random() * 0.02 + 0.01;
                clouds.push(cloudGroup); scene.add(cloudGroup);
            }

            if (stars) { if (stars.parent) stars.parent.remove(stars); if (stars.geometry) stars.geometry.dispose(); if (stars.material) stars.material.dispose(); stars = null;}
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, sizeAttenuation: true, transparent: true, opacity: 0, depthWrite: false });
            const starVertices = [];
            for (let i = 0; i < effectiveNumStars; i++) { // Use effectiveNumStars
                starVertices.push(THREE.MathUtils.randFloatSpread(roadLength * 3), THREE.MathUtils.randFloat(50, 150), THREE.MathUtils.randFloatSpread(roadLength * 3));
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function loadCarModels() {
            console.log("loadCarModels called.");
            const loader = new GLTFLoader(loadingManager);
            const dracoLoader = new DRACOLoader(loadingManager);
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
            loader.setDRACOLoader(dracoLoader);
            const carUrl = 'https://threejs.org/examples/models/gltf/ferrari.glb'; // This model might be high-poly

            loader.load(carUrl, (gltf) => {
                console.log("Ferrari GLB loaded successfully.");
                carModel = gltf.scene; carModel.scale.set(0.7,0.7,0.7);
                const tempBox = new THREE.Box3().setFromObject(carModel); tempBox.getSize(playerSize);
                carBaseY = -tempBox.min.y * carModel.scale.y + 0.02; carModel.position.set(0, carBaseY, -5); carModel.rotation.y = Math.PI;
                carModel.traverse((node) => { if (node.isMesh) { node.castShadow = true; node.receiveShadow = true; } }); // Player car casts shadow
                scene.add(carModel);
                
                headlightLeft = new THREE.SpotLight(0xffffee,0,30,Math.PI/6,0.3,1); headlightLeft.castShadow = false; headlightLeft.visible = false; // Headlights don't cast shadow
                headlightLeft.position.set(-0.7,0.6,2.0).multiplyScalar(carModel.scale.x); carModel.add(headlightLeft); carModel.add(headlightLeft.target);
                headlightLeft.target.position.set(-0.6,0.3,10).multiplyScalar(carModel.scale.x);
                headlightRight = headlightLeft.clone(); headlightRight.visible = false; headlightRight.position.set(0.7,0.6,2.0).multiplyScalar(carModel.scale.x);
                carModel.add(headlightRight); carModel.add(headlightRight.target); headlightRight.target.position.set(0.6,0.3,10).multiplyScalar(carModel.scale.x);
                
                taillightLeft = new THREE.PointLight(0xff0000,0,5,2); taillightLeft.castShadow = false; taillightLeft.position.set(-0.8,0.5,-2.2).multiplyScalar(carModel.scale.x); carModel.add(taillightLeft);
                taillightRight = taillightLeft.clone(); taillightRight.castShadow = false; taillightRight.position.set(0.8,0.5,-2.2).multiplyScalar(carModel.scale.x); carModel.add(taillightRight);
                
                enemyCar = carModel.clone(); const tempEnemyBox = new THREE.Box3().setFromObject(enemyCar); tempEnemyBox.getSize(enemySize);
                enemyCar.traverse((node) => {
                    if (node.isMesh) { 
                        const blueMaterial = node.material.clone(); blueMaterial.color.setHex(0x3366ff); node.material = blueMaterial; 
                        node.castShadow = true; node.receiveShadow = true; // Enemy car also casts shadow
                    }
                    if (node.isLight) node.intensity = 0; // Disable lights on enemy car clone
                });
                resetEnemyCar(); scene.add(enemyCar);
                camera.position.set(0,carBaseY+2.8,carModel.position.z-6.5); camera.lookAt(carModel.position.x,carBaseY+1.0,carModel.position.z+3.0);
            },
            null, // onProgress callback (not used here for the main model)
            (error) => {
                console.error('Error loading car model (ferrari.glb):', error); // Fallback if model fails
                const fallbackGeo = new THREE.BoxGeometry(1.8,1,3.5); playerSize.set(1.8,1,3.5); enemySize.copy(playerSize);
                const fallbackMat = new THREE.MeshStandardMaterial({color:0xff0000}); carModel = new THREE.Mesh(fallbackGeo,fallbackMat);
                carBaseY = 0.5+0.01; carModel.position.set(0,carBaseY,-5); carModel.castShadow = true; carModel.receiveShadow = true;
                scene.add(carModel); 
                enemyCar = carModel.clone(); // Fallback enemy car
                resetEnemyCar(); scene.add(enemyCar);
                camera.position.set(0,carBaseY+2.8,carModel.position.z-6.5); camera.lookAt(carModel.position.x,carBaseY+1.0,carModel.position.z+3.0);
            });
        }

        function initiateCountdown() {
            console.log("initiateCountdown called.");
            if (countdownInterval) clearInterval(countdownInterval);
            isGameOver = false;
            isCountingDown = true;
            gameHasStartedAfterCountdown = false;
            countdownValue = 3;

            if(carModel) {
                carModel.position.set(0, carBaseY, -5);
                carModel.rotation.set(0, Math.PI, 0);
            }
            carVelocity = 0;

            if (countdownDisplayElement) {
                countdownDisplayElement.textContent = countdownValue;
                countdownDisplayElement.style.display = 'block';
            } else {
                console.warn("Countdown display element not found!");
            }
            if (sounds.engine) stopSound('engine');

             if (!loadingScreen.classList.contains('hidden')) {
                loadingScreen.classList.add('hidden');
            }

            countdownInterval = setInterval(() => {
                countdownValue--;
                if (countdownDisplayElement) {
                    if (countdownValue > 0) {
                        countdownDisplayElement.textContent = countdownValue;
                    } else if (countdownValue === 0) {
                        countdownDisplayElement.textContent = "GO!";
                    } else {
                        clearInterval(countdownInterval);
                        countdownInterval = null;
                        countdownDisplayElement.style.display = 'none';
                        isCountingDown = false;
                        gameHasStartedAfterCountdown = true;
                        console.log("Countdown finished. Game started!");
                        if (!isGameOver && currentPageId === 'game-page' && sounds.engine) {
                            playSound('engine', true);
                        }
                    }
                } else { // Fallback if display element is somehow lost
                     clearInterval(countdownInterval);
                     countdownInterval = null;
                     isCountingDown = false;
                     gameHasStartedAfterCountdown = true;
                     console.log("Countdown finished (no display element). Game started!");
                     if (!isGameOver && currentPageId === 'game-page' && sounds.engine) playSound('engine', true);
                }
            }, 1000);
        }


        function setupControls() {
            window.addEventListener('keydown', (event) => {
                if (isGameOver || isCountingDown || currentPageId !== 'game-page') return;
                switch (event.key.toLowerCase()) {
                    case 'arrowleft': case 'a': moveLeft = true; break;
                    case 'arrowright': case 'd': moveRight = true; break;
                    case 'r': isRaining = !isRaining; updateRainSound(); break; // Toggle rain for debug
                }
            });
            window.addEventListener('keyup', (event) => {
                if (currentPageId !== 'game-page') return; // Keyup can happen on any page
                switch (event.key.toLowerCase()) {
                    case 'arrowleft': case 'a': moveLeft = false; break;
                    case 'arrowright': case 'd': moveRight = false; break;
                }
            });

            const leftBtn = document.getElementById('left-button');
            const rightBtn = document.getElementById('right-button');

            const gamePage = document.getElementById('game-page');
            if (gamePage) {
                gamePage.addEventListener('touchmove', (e) => { // Prevent scrolling/zooming on game page
                    if (currentPageId === 'game-page') {
                        e.preventDefault();
                    }
                }, { passive: false });
            }

            const handleTouchStart = (e, direction) => {
                if (!isGameOver && !isCountingDown && currentPageId === 'game-page') {
                    e.preventDefault(); // Prevent default only if game is active
                    if (direction === 'left') moveLeft = true;
                    if (direction === 'right') moveRight = true;
                }
            };

            const handleTouchEnd = (e, direction) => {
                 // No preventDefault here by default, as it might interfere with other UI if game is over
                if (currentPageId === 'game-page') { // Only act if on game page
                    if (direction === 'left') moveLeft = false;
                    if (direction === 'right') moveRight = false;
                }
            };

            if (leftBtn) {
                leftBtn.addEventListener('touchstart', (e) => handleTouchStart(e, 'left'), { passive: false });
                leftBtn.addEventListener('touchend', (e) => handleTouchEnd(e, 'left'), { passive: true }); // touchend can be passive
                leftBtn.addEventListener('touchcancel', (e) => handleTouchEnd(e, 'left'), { passive: true });
            }

            if (rightBtn) {
                rightBtn.addEventListener('touchstart', (e) => handleTouchStart(e, 'right'), { passive: false });
                rightBtn.addEventListener('touchend', (e) => handleTouchEnd(e, 'right'), { passive: true });
                rightBtn.addEventListener('touchcancel', (e) => handleTouchEnd(e, 'right'), { passive: true });
            }
            
            const addTouchFeedback = (button) => { // Visual feedback for buttons
                if (!button) return;
                button.addEventListener('touchstart', () => {
                    button.style.backgroundColor = 'rgba(255, 255, 255, 0.65)';
                }, { passive: true });
                button.addEventListener('touchend', () => {
                    button.style.backgroundColor = 'rgba(200, 200, 200, 0.45)';
                }, { passive: true });
                button.addEventListener('touchcancel', () => {
                    button.style.backgroundColor = 'rgba(200, 200, 200, 0.45)';
                }, { passive: true });
            };

            addTouchFeedback(leftBtn);
            addTouchFeedback(rightBtn);
        }

        function updateRainSound() {
             if (!sounds.rain) return;
             if (isRaining && currentPageId === 'game-page' && !isGameOver && !isCountingDown) playSound('rain', true);
             else stopSound('rain');
        }

        function restartGame() {
            console.log("restartGame called.");
            isGameOver = false;
            score = 0; distanceTraveled = 0; carVelocity = 0; currentDisplaySpeed = 0;
            carCurrentYOffset = 0; suspensionVelocity = 0;
            currentPatternIndex = 0; coinsInCurrentPattern = 0; targetCoinsForPattern = 5 + Math.floor(Math.random() * 3);
            lastUiUpdateTime = 0; 

            resetEnemyCar();
            points.forEach(p => resetPointPosition(p, true));

            if (skidInstanceMesh) {
                skidInstanceData.forEach(d => d.active = false); // Deactivate all
                skidInstanceMesh.count = 0;
                if(skidInstanceMesh.instanceMatrix) skidInstanceMesh.instanceMatrix.needsUpdate = true;
                nextSkidMarkIndex = 0;
            }
            if (exhaustInstanceMesh) {
                exhaustInstanceData.forEach(d => d.active = false); // Deactivate all
                exhaustInstanceMesh.count = 0;
                if(exhaustInstanceMesh.instanceMatrix) exhaustInstanceMesh.instanceMatrix.needsUpdate = true;
            }
            if (rainInstanceMesh) {
                rainInstanceData.forEach(data => data.active = false); 
                rainInstanceMesh.count = 0; 
                if(rainInstanceMesh.instanceMatrix) rainInstanceMesh.instanceMatrix.needsUpdate = true;
            }
            if (roadLineInstanceMesh) { 
                roadLineInstanceMesh.position.z = 0;
            }


            gameOverElement.style.display = 'none';
            updateScoreDisplay(); updateDistanceDisplay(); updateSpeedometer(); 

            if (sounds.engine) stopSound('engine');
            updateRainSound(); // Handles stopping rain sound if it was on
            updateDayCycleAndWeather(0); // Reset visual state
            if (camera) { camera.fov = baseFov; camera.updateProjectionMatrix(); }

            initiateCountdown();
        }

        function resetEnemyCar() {
             if (!enemyCar || !carModel) return; enemyCar.rotation.y = 0; // Assuming enemy always faces forward relative to world
            const initialEnemyX = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 4) * (0.8 + Math.random() * 0.4);
            const initialEnemyZ = carModel.position.z + roadLength * (0.7 + Math.random() * 0.5); // Spawn ahead of player
            enemyCar.position.set(initialEnemyX, carBaseY, initialEnemyZ);
            enemyTargetX = initialEnemyX; enemyCar.visible = true;
        }

        function resetPointPosition(point, initial = false) {
            const laneXOffset = roadWidth / 4; let targetX;
            if (coinsInCurrentPattern >= targetCoinsForPattern) {
                currentPatternIndex = (currentPatternIndex + 1) % coinPatterns.length;
                coinsInCurrentPattern = 0; targetCoinsForPattern = 5 + Math.floor(Math.random() * 3);
            }
            const currentPattern = coinPatterns[currentPatternIndex];
            switch (currentPattern) { case 'left': targetX = -laneXOffset; break; case 'right': targetX = laneXOffset; break; default: targetX = 0; }
            point.position.x = targetX; point.position.y = pointRadius + 0.02; // Slightly above ground
            const carZ = carModel ? carModel.position.z : 0;
            if (initial) { point.position.z = carZ + 20 + (points.indexOf(point) * 12); } // Spread out initially
            else { // Reposition ahead of the furthest coin in the same lane or ahead of car
                let furthestVisibleCoinZInLane = carZ; // Start with car's Z
                points.forEach(p => { 
                    if (p.visible && p !== point && Math.abs(p.position.x - targetX) < 0.01 && p.position.z > furthestVisibleCoinZInLane) {
                        furthestVisibleCoinZInLane = p.position.z; 
                    }
                });
                const ZSpacingInPattern = 10 + Math.random() * 5; 
                const minZFromCar = carZ + roadLength * 0.4; // Ensure it's far enough ahead
                let newZ = (furthestVisibleCoinZInLane > carZ + 1) ? furthestVisibleCoinZInLane + ZSpacingInPattern : minZFromCar + Math.random() * roadLength * 0.2;
                point.position.z = Math.max(newZ, minZFromCar);
            }
            coinsInCurrentPattern++; point.visible = true;
        }

        function updateScoreDisplay() { if(scoreElement) scoreElement.textContent = `Score: ${score}`; }
        function updateDistanceDisplay() { if(distanceElement) distanceElement.textContent = `Distance: ${Math.floor(distanceTraveled)} m`; }
        function updateSpeedometer() {
             currentDisplaySpeed = Math.floor(Math.abs(carVelocity * 100)); // km/h like display
             if(speedometerElement) speedometerElement.textContent = `Speed: ${currentDisplaySpeed} km/h`;
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            const newWidth = window.innerWidth; const newHeight = window.innerHeight;
            
            // This will update reduceEnvironmentComplexityMobile and related settings
            updatePerformanceSettings(); 
            // createEnvironmentAssets(); // This would be too heavy for every resize.
                                     // For now, complexity is set at init.
                                     // A more robust solution would dynamically adjust assets.

            camera.aspect = newWidth / newHeight; camera.updateProjectionMatrix();
            // renderer.setSize is handled by updatePerformanceSettings
        }

        // --- Instanced Particle System: Rain ---
        function createRainParticleSystem_Instanced() {
            if (rainInstanceMesh) { scene.remove(rainInstanceMesh); rainInstanceMesh.geometry.dispose(); rainInstanceMesh.material.dispose(); }
            const rainGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.7, reduceEnvironmentComplexityMobile ? 3 : 5); 
            const rainMat = new THREE.MeshBasicMaterial({ color:0xabcdef, transparent:true, opacity:0.3, depthWrite: false });
            rainInstanceMesh = new THREE.InstancedMesh(rainGeo, rainMat, ABSOLUTE_MAX_RAIN_PARTICLES); // Use absolute max for mesh creation
            rainInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            rainInstanceMesh.visible = false; 
            scene.add(rainInstanceMesh);
            rainInstanceData = [];
            for (let i = 0; i < ABSOLUTE_MAX_RAIN_PARTICLES; i++) {
                const yPos = Math.random() * 25 + 15; // Initial Y range relative to camera
                rainInstanceData.push({
                    matrix: new THREE.Matrix4(), // Will be set when activated
                    initialY: yPos,
                    speed: 1.2 + Math.random() * 0.8, 
                    active: false 
                });
            }
        }

        function updateRainParticles_Instanced(delta) {
            if (!rainInstanceMesh || !isRaining || !gameHasStartedAfterCountdown || !camera) {
                if(rainInstanceMesh) rainInstanceMesh.visible = false;
                return;
            }
            rainInstanceMesh.visible = true;
            let activeCount = 0;
            const tiltAngle = -carVelocity * 0.07; 

            rainInstanceData.forEach((data, i) => {
                if (!data.active && activeCount < effectiveMaxRainParticles && Math.random() < 0.05) { // Activate if below effective max
                    data.active = true;
                     _tempObject.position.set(
                        camera.position.x + (Math.random() - 0.5) * roadWidth * 4, // Wider spawn area
                        camera.position.y + data.initialY + (Math.random() - 0.5) * 10, // Spawn relative to camera Y
                        camera.position.z + (Math.random() - 0.5) * roadLength * 0.8 + carVelocity * 10 // Spawn ahead
                    );
                    _tempObject.rotation.set(0,0,0); _tempObject.scale.set(1,1,1); // Reset rotation/scale
                    _tempObject.updateMatrix();
                    data.matrix.copy(_tempObject.matrix);
                }

                if (data.active) {
                    _tempObject.matrix.copy(data.matrix);
                    _tempObject.matrix.decompose(_tempObject.position, _tempObject.quaternion, _tempObject.scale);

                    _tempObject.position.y -= (data.speed + carVelocity * 0.4) * delta * 10; 
                    _tempEuler.set(tiltAngle, 0, (Math.random() - 0.5) * 0.1); 
                    _tempObject.quaternion.setFromEuler(_tempEuler);

                    if (_tempObject.position.y < camera.position.y - 10) { // Recycle if far below camera
                        data.active = false; 
                    } else {
                        _tempObject.updateMatrix();
                        data.matrix.copy(_tempObject.matrix);
                        rainInstanceMesh.setMatrixAt(activeCount, data.matrix);
                        activeCount++;
                    }
                }
            });
            rainInstanceMesh.count = activeCount;
            if (activeCount > 0) rainInstanceMesh.instanceMatrix.needsUpdate = true;
        }

        // --- Instanced Particle System: Exhaust ---
        function createExhaustParticleSystem_Instanced() {
            if (exhaustInstanceMesh) { scene.remove(exhaustInstanceMesh); exhaustInstanceMesh.geometry.dispose(); exhaustInstanceMesh.material.dispose(); }
            const exhaustGeo = new THREE.SphereGeometry(0.08, reduceEnvironmentComplexityMobile ? 4 : 6, reduceEnvironmentComplexityMobile ? 2 : 3); 
            const exhaustMat = new THREE.MeshBasicMaterial({ color:0xcccccc, transparent:true, opacity:0.4, depthWrite:false });
            exhaustInstanceMesh = new THREE.InstancedMesh(exhaustGeo, exhaustMat, ABSOLUTE_MAX_EXHAUST_PARTICLES);
            exhaustInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(exhaustInstanceMesh);
            exhaustInstanceData = []; 
            for (let i=0; i<ABSOLUTE_MAX_EXHAUST_PARTICLES; ++i) {
                exhaustInstanceData.push({ matrix: new THREE.Matrix4(), age:0, maxAge:0, active:false});
            }
        }
        
        function addExhaustInstance_Instanced() {
            if (!carModel || !exhaustInstanceMesh || !gameHasStartedAfterCountdown || carVelocity < 0.1) return;

            let availableIndex = -1;
            let currentActiveCount = 0;
            for(let i=0; i < exhaustInstanceData.length; i++) {
                if(exhaustInstanceData[i].active) currentActiveCount++;
                else if (availableIndex === -1) availableIndex = i;
            }

            if (currentActiveCount >= effectiveMaxExhaustParticles) return; // Respect effective limit

            if(availableIndex !== -1) {
                const data = exhaustInstanceData[availableIndex];
                data.active = true;
                data.age = 0;
                data.maxAge = 0.6 + Math.random()*0.3 + carVelocity * 0.2; 

                _tempObject.position.copy(carModel.position);
                const localOffset = new THREE.Vector3((Math.random()-0.5)*0.3, -0.15, -1.9 * (carModel.scale.z || 0.8));
                localOffset.applyQuaternion(carModel.quaternion);
                _tempObject.position.add(localOffset);
                _tempObject.position.y = Math.max(0.15, _tempObject.position.y); 

                _tempObject.quaternion.identity(); 
                _tempObject.scale.set(0.1,0.1,0.1); 
                _tempObject.updateMatrix();
                data.matrix.copy(_tempObject.matrix);
            }
        }

        function updateExhaustParticles_Instanced(delta) {
            if (!exhaustInstanceMesh || !gameHasStartedAfterCountdown) return;
            let activeCountVisual = 0; // For setting InstancedMesh.count

            if (carVelocity > 0.1 && Math.random() < 0.6) { 
                 addExhaustInstance_Instanced(); // addExhaustInstance will respect effectiveMaxExhaustParticles
            }

            exhaustInstanceData.forEach(data => {
                if(data.active) {
                    data.age += delta;
                    if (data.age > data.maxAge) {
                        data.active = false;
                    } else {
                        _tempObject.matrix.copy(data.matrix);
                        _tempObject.matrix.decompose(_tempObject.position, _tempObject.quaternion, _tempObject.scale);

                        _tempObject.position.y += (0.01 + carVelocity * 0.005) * (1 - data.age/data.maxAge); 
                        _tempObject.position.x -= carVelocity * 0.003 * (1 - data.age/data.maxAge); 
                        _tempObject.position.z -= carVelocity * baseDriveSpeed * delta * 0.3; 

                        const scaleFactor = 0.1 + (data.age / data.maxAge) * (0.8 + carVelocity * 0.3); 
                        _tempObject.scale.set(scaleFactor, scaleFactor, scaleFactor);
                        
                        _tempObject.updateMatrix();
                        data.matrix.copy(_tempObject.matrix);
                        exhaustInstanceMesh.setMatrixAt(activeCountVisual, data.matrix);
                        activeCountVisual++;
                    }
                }
            });
            exhaustInstanceMesh.count = activeCountVisual;
            if(activeCountVisual > 0) exhaustInstanceMesh.instanceMatrix.needsUpdate = true;
            exhaustInstanceMesh.material.opacity = Math.max(0.1, 0.6 - (activeCountVisual / effectiveMaxExhaustParticles) * 0.5);
        }


        // --- Instanced Particle System: Skid Marks ---
        function createSkidMarkSystem_Instanced() {
            if (skidInstanceMesh) { scene.remove(skidInstanceMesh); skidInstanceMesh.geometry.dispose(); skidInstanceMesh.material.dispose(); }
            const skidGeo = new THREE.PlaneGeometry(0.4, 1.2); 
            const skidMat = new THREE.MeshStandardMaterial({
                color:0x1a1a1a, transparent:true, opacity:0.8,
                roughness:0.9, depthWrite:false, side: THREE.DoubleSide 
            });
            skidInstanceMesh = new THREE.InstancedMesh(skidGeo, skidMat, ABSOLUTE_MAX_SKID_MARKS);
            skidInstanceMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(skidInstanceMesh);
            skidInstanceData = []; 
            for(let i=0; i < ABSOLUTE_MAX_SKID_MARKS; ++i) {
                 skidInstanceData.push({ matrix: new THREE.Matrix4(), age:0, maxAge:0, active:false});
            }
            nextSkidMarkIndex = 0;
        }

        function addSkidMarkInstance_Instanced(worldPosition, carRotationY) {
            if (!skidInstanceMesh || !gameHasStartedAfterCountdown) return;
            
            // Check if we are exceeding effectiveMaxSkidMarks by counting active ones.
            // This is tricky because we use a circular buffer (nextSkidMarkIndex).
            // A simpler approach: if nextSkidMarkIndex is about to overwrite a still young particle
            // and we are at capacity for mobile, maybe don't add one.
            // For now, we'll rely on the fact that older marks fade.
            // The primary constraint will be visual density.

            const currentData = skidInstanceData[nextSkidMarkIndex]; // Overwrite oldest or unused
            currentData.active = true;
            currentData.age = 0;
            currentData.maxAge = 2.5 + Math.random()*1.5 + carVelocity * 0.5;

            _tempObject.position.copy(worldPosition);
            _tempObject.position.y = 0.011; 

            _tempEuler.set(-Math.PI / 2, 0, carRotationY - Math.PI/2); 
            _tempObject.quaternion.setFromEuler(_tempEuler);
            _tempObject.scale.set(1,1,1); 
            _tempObject.updateMatrix();
            currentData.matrix.copy(_tempObject.matrix);

            nextSkidMarkIndex = (nextSkidMarkIndex + 1) % effectiveMaxSkidMarks; // Use effectiveMax for cycling index on mobile
                                                                                // to reduce visual density faster
            if (skidInstanceData.length < effectiveMaxSkidMarks && nextSkidMarkIndex >= skidInstanceData.length) {
                 // This logic for populating skidInstanceData up to effectiveMaxSkidMarks
                 // is not quite right with pre-sized array.
                 // Better to always cycle through ABSOLUTE_MAX_SKID_MARKS using nextSkidMarkIndex % ABSOLUTE_MAX_SKID_MARKS
                 // and control visual count in updateSkidMarks_Instanced.
            }
            // Corrected logic for circular buffer index:
            nextSkidMarkIndex = (nextSkidMarkIndex + 1) % ABSOLUTE_MAX_SKID_MARKS;

        }

        function updateSkidMarks_Instanced(delta, worldMovementZ) {
            if (!skidInstanceMesh) return;
            let activeCountVisual = 0;
            skidInstanceData.forEach(data => {
                if(data.active) {
                    data.age += delta;
                    if (data.age > data.maxAge) {
                        data.active = false; 
                    } else {
                        if (activeCountVisual < effectiveMaxSkidMarks) { // Only draw up to effective limit
                            _tempObject.matrix.copy(data.matrix);
                            _tempObject.matrix.decompose(_tempObject.position, _tempObject.quaternion, _tempObject.scale);
                            _tempObject.position.z -= worldMovementZ; 

                            _tempObject.updateMatrix();
                            data.matrix.copy(_tempObject.matrix);

                            skidInstanceMesh.setMatrixAt(activeCountVisual, data.matrix);
                            activeCountVisual++;
                        } else {
                            // If we are over the effective limit for mobile, older "active" particles might not be drawn
                            // This helps reduce overdraw if many skid marks were generated quickly.
                            // To ensure they eventually fade, we could force them inactive sooner on mobile:
                            if (reduceEnvironmentComplexityMobile && data.age > data.maxAge * 0.6) {
                                data.active = false;
                            }
                        }
                    }
                }
            });
            skidInstanceMesh.count = activeCountVisual;
            if (activeCountVisual > 0) skidInstanceMesh.instanceMatrix.needsUpdate = true;
        }


        function animate() {
            requestAnimationFrame(animate);
            if (!renderer || !scene || !camera || !carModel) return;
            if (stats) stats.begin();

            if (currentPageId !== 'game-page' && !isGameOver) { // Not on game page and not game over
                if (stats) stats.end();
                return;
            }

            const delta = clock.getDelta();
            const nowTime = clock.elapsedTime * 1000; // For UI throttle

            if (isCountingDown) {
                if(renderer && scene && camera) renderer.render(scene, camera); // Render scene during countdown
                if (stats) stats.end();
                return;
            }

            if (isGameOver) { // Game is over, fade engine sound and render static scene
                if (sounds.engine && sounds.engine.volume > 0.01) {
                    sounds.engine.volume -= 0.01;
                    sounds.engine.playbackRate = Math.max(0.1, sounds.engine.playbackRate - 0.01);
                } else if (sounds.engine) {
                    stopSound('engine');
                }
                if(renderer && scene && camera) renderer.render(scene, camera);
                if (stats) stats.end();
                return;
            }

            if (currentPageId !== 'game-page') { // Should be caught earlier, but safeguard
                 if (stats) stats.end();
                 return;
            }


            let prevCarVelocity = carVelocity;
            if (gameHasStartedAfterCountdown && !isGameOver) {
                carVelocity = Math.min(carVelocity + carAcceleration, maxSpeed);
            } else { // Should not happen if countdown leads to gameHasStartedAfterCountdown
                carVelocity = Math.max(carVelocity - carDeceleration, 0);
            }
            let accelerationEffect = (delta > 0) ? (carVelocity - prevCarVelocity) / delta : 0;

            const actualSpeed = carVelocity * baseDriveSpeed;
            const worldMovementZ = actualSpeed * delta * 60; 

            if (gameHasStartedAfterCountdown && carVelocity > 0) {
                distanceTraveled += worldMovementZ * 2; 
            }

            let targetRotationZ = 0; // Car body roll
            const effectiveTurnSpeed = carTurnSpeed * (1 + carVelocity * 0.5); // Faster turn at higher speed
            if (carModel.geometry) playerBox.setFromObject(carModel); // Update player bounding box
            else if (playerSize.x > 0) { // Fallback if carModel is group without immediate geometry
                 const carPos = carModel.position;
                 playerBox.min.set(carPos.x - playerSize.x/2, carPos.y - playerSize.y/2, carPos.z - playerSize.z/2);
                 playerBox.max.set(carPos.x + playerSize.x/2, carPos.y + playerSize.y/2, carPos.z + playerSize.z/2);
            }

            const carWidth = playerSize.x;
            const maxBounds = roadWidth / 2 - kerbWidth - carWidth / 2 - 0.1; // Max X displacement
            let turningEffect = 0; // For suspension

            if (gameHasStartedAfterCountdown && !isGameOver) {
                let newX = carModel.position.x;

                if (moveLeft) {
                    newX -= effectiveTurnSpeed * delta * 60; 
                    targetRotationZ = Math.PI / 20; // Roll left
                    turningEffect = -0.05;
                }
                if (moveRight) {
                    newX += effectiveTurnSpeed * delta * 60; 
                    targetRotationZ = -Math.PI / 20; // Roll right
                    turningEffect = 0.05; 
                }


                if (newX >= -maxBounds && newX <= maxBounds) { // Within road kerbs
                    carModel.position.x = newX;
                     if ((moveLeft || moveRight) && carVelocity > 0.3 && Date.now() - lastSkidTime > skidInterval) {
                        addSkidMarkInstance_Instanced(carModel.getWorldPosition(new THREE.Vector3()), carModel.rotation.y + targetRotationZ * 2.5);
                        lastSkidTime = Date.now();
                        if (sounds.skid && Math.random() < 0.3) playSound('skid', false, 0.3);
                    }
                } else { // Clamped by kerbs
                     carModel.position.x = THREE.MathUtils.clamp(carModel.position.x, -maxBounds, maxBounds);
                }
            }


            carModel.rotation.z = THREE.MathUtils.lerp(carModel.rotation.z, targetRotationZ * carVelocity, 0.1); // Apply roll

            // Suspension effect
            let force = -suspensionStiffness * carCurrentYOffset - suspensionDamping * suspensionVelocity + accelerationEffect * 0.005 + turningEffect * carVelocity * 0.1;
            suspensionVelocity += force * delta; carCurrentYOffset += suspensionVelocity * delta;
            carCurrentYOffset = THREE.MathUtils.clamp(carCurrentYOffset, -0.05, 0.05); // Limit suspension travel
            carModel.position.y = carBaseY + carCurrentYOffset;

            const objectsToScroll = [ ...buildings, ...streetLights, ...trafficLights, ...kerbs, ...points ];
            if (enemyCar && enemyCar.visible) objectsToScroll.push(enemyCar);
            objectsToScroll.forEach(obj => obj.position.z -= worldMovementZ);

            if (roadLineInstanceMesh) {
                roadLineInstanceMesh.position.z -= worldMovementZ;
                if (roadLineInstanceMesh.position.z < -roadLength / 2 - 20) { 
                    roadLineInstanceMesh.position.z += roadLength; // Wrap around by one full road segment length
                }
            }


            const recycleThreshold = -roadLength / 2 - 20; // Common Z threshold for recycling
            kerbs.forEach(kerb => { if (kerb.position.z < recycleThreshold - roadLength / 2) kerb.position.z += roadLength * 2; }); 
            buildings.forEach(building => {
                if (building.position.z < recycleThreshold - building.geometry.parameters.depth) { // Check based on building depth
                    const currentBuildingSpacing = buildingSpacingBase * (reduceEnvironmentComplexityMobile ? 2.5 : 1.0);
                    building.position.z += roadLength + Math.random() * currentBuildingSpacing * 1.5; // Reposition far ahead
                    const sideSign = Math.sign(building.position.x) || (Math.random() < 0.5 ? -1 : 1); // Keep side or randomize
                    const xOffset = roadWidth / 2 + kerbWidth + 2 + Math.random() * 8 + building.geometry.parameters.width / 2;
                    building.position.x = sideSign * xOffset;
                }
            });
            streetLights.forEach(light => { if (light.position.z < recycleThreshold) light.position.z += roadLength + Math.random() * lightSpacingBase * 2; });
            trafficLights.forEach(light => { if (light.position.z < recycleThreshold) light.position.z += roadLength * 1.5 + Math.random() * roadLength; });
            points.forEach(point => { if (point.position.z < carModel.position.z - 20 && point.visible) resetPointPosition(point); });


            updateDayCycleAndWeather(delta); 
            updateEnemyAI(delta, worldMovementZ);
            updateExhaustParticles_Instanced(delta);
            updateSkidMarks_Instanced(delta, worldMovementZ); 


            // Camera follow logic
            const targetCameraPos = new THREE.Vector3( carModel.position.x*0.25, carModel.position.y + 2.5 + carVelocity*0.4, carModel.position.z - 6.5 - carVelocity*2.0 );
            camera.position.lerp(targetCameraPos, 0.12); // Smooth camera movement
            const lookAtPos = new THREE.Vector3( carModel.position.x*0.4, carModel.position.y + 1.0, carModel.position.z + 4.0 );
            camera.lookAt(lookAtPos);
            camera.fov = THREE.MathUtils.lerp(camera.fov, baseFov + carVelocity * 8, 0.05); // Dynamic FOV
            camera.updateProjectionMatrix();

            // Collision with points (coins)
            points.forEach(point => {
                if (!point.visible) return; 
                pointBox.setFromObject(point);
                if (playerBox.intersectsBox(pointBox)) {
                    score += pointValue;
                    point.visible = false;
                    if(sounds.collect) playSound('collect', false, 0.6);
                    // Respawn coin after a delay
                    setTimeout(() => { if(!point.visible && !isGameOver) resetPointPosition(point);}, 500 + Math.random()*1000);
                }
            });

            // Collision with enemy car
            if (enemyCar && enemyCar.visible) {
                if (enemyCar.geometry) enemyBox.setFromObject(enemyCar);
                else if (enemySize.x > 0) { // Fallback if enemyCar is group without immediate geometry
                     const enemyPos = enemyCar.position;
                     enemyBox.min.set(enemyPos.x - enemySize.x/2, enemyPos.y - enemySize.y/2, enemyPos.z - enemySize.z/2);
                     enemyBox.max.set(enemyPos.x + enemySize.x/2, enemyPos.y + enemySize.y/2, enemyPos.z + enemySize.z/2);
                }


                if (playerBox.intersectsBox(enemyBox)) handleGameOver();
                else if (nearMissCooldown <= 0) { // Near miss detection
                    const distZ = Math.abs(carModel.position.z - enemyCar.position.z); 
                    const distX = Math.abs(carModel.position.x - enemyCar.position.x);
                    const carCombinedHalfWidth = playerSize.x/2 + enemySize.x/2; 
                    const carCombinedHalfLength = playerSize.z/2 + enemySize.z/2;
                    // Check for close proximity for near miss
                    if (distZ < carCombinedHalfLength*1.5 && distX < carCombinedHalfWidth*1.8 && distX > carCombinedHalfWidth*0.9 && carVelocity > 0.3) {
                        score += nearMissBonus;
                        if(sounds.nearMiss) playSound('nearMiss', false, 0.4); 
                        nearMissCooldown = 1.5; // Cooldown for near miss bonus
                    }
                }
            }
            if (nearMissCooldown > 0) nearMissCooldown -= delta;

            if (nowTime - lastUiUpdateTime > UI_UPDATE_INTERVAL) {
                updateScoreDisplay();
                updateDistanceDisplay();
                updateSpeedometer();
                lastUiUpdateTime = nowTime;
            }

            if(gameHasStartedAfterCountdown) updateEngineSound();
            if(renderer && scene && camera) renderer.render(scene, camera);
            if (stats) stats.end();
        }

        function handleGameOver() {
             if (isGameOver) return;
             console.log("Game Over!");
             isGameOver = true; gameHasStartedAfterCountdown = false;
            if(finalScoreDisplayElement) finalScoreDisplayElement.textContent = `Distance: ${Math.floor(distanceTraveled)} m | Score: ${score}`;
            gameOverElement.style.display = 'flex'; handleAdSlotVisibility('ad-slot-game-over');
            saveScoreToLeaderboard(currentPlayerName, Math.floor(distanceTraveled));
            if (sounds.rain) stopSound('rain');
            // Engine sound fade out is handled in animate() loop when isGameOver is true
        }

        function saveScoreToLeaderboard(playerName, currentDistance) {
            if (!playerName) playerName = "Player";
            try {
                const scoresJSON = localStorage.getItem(LEADERBOARD_KEY); let scores = scoresJSON ? JSON.parse(scoresJSON) : [];
                scores.push({ name: playerName, score: currentDistance });
                scores.sort((a, b) => b.score - a.score); scores = scores.slice(0, MAX_LEADERBOARD_ENTRIES);
                localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(scores));
            } catch (e) { console.error("Could not save score to leaderboard:", e); }
        }

        function displayLeaderboard() {
            try {
                const scoresJSON = localStorage.getItem(LEADERBOARD_KEY); const scores = scoresJSON ? JSON.parse(scoresJSON) : [];
                leaderboardListElement.innerHTML = ''; // Clear previous list
                if (scores.length > 0) {
                    noScoresMessageElement.style.display = 'none';
                    scores.forEach(scoreItem => {
                        const li = document.createElement('li');
                        const nameSpan = document.createElement('span'); nameSpan.className = 'leaderboard-name'; nameSpan.textContent = scoreItem.name;
                        const scoreSpan = document.createElement('span'); scoreSpan.className = 'leaderboard-score'; scoreSpan.textContent = `${scoreItem.score} m`;
                        li.appendChild(nameSpan); li.appendChild(scoreSpan); leaderboardListElement.appendChild(li);
                    });
                } else noScoresMessageElement.style.display = 'block';
            } catch (e) {
                console.error("Could not display leaderboard:", e);
                leaderboardListElement.innerHTML = '<li>Error loading scores.</li>'; noScoresMessageElement.style.display = 'none';
            }
        }

        function updateDayCycleAndWeather(delta) {
            timeOfDay = 0.5; // Force daytime for performance

            const sunAngle = (timeOfDay - 0.25) * Math.PI * 2; // Sun rises at 0.25, sets at 0.75
            let sunIntensity = Math.max(0, Math.sin(sunAngle)); // Intensity based on sun angle
            let nightFactor = 1.0 - sunIntensity; // How "night-like" it is

            if (!ambientLight || !directionalLight || !scene.fog || !scene.background) return; // Safety check
            
            ambientLight.intensity = 0.4 + sunIntensity * 0.6; // Ambient light based on sun
            directionalLight.intensity = 0.6 + sunIntensity * 1.2; // Directional light based on sun
            directionalLight.position.y = 50 + sunIntensity * 50; // Sun height

            if (lensflare) lensflare.visible = !reduceEnvironmentComplexityMobile && directionalLight.intensity > 0.1;

            const dayColor = new THREE.Color(0xa0d7e6); // Sky blue for day
            // const nightColor = new THREE.Color(0x080f1a); // Dark blue for night (not used due to forced daytime)
            // scene.background.lerpColors(nightColor, dayColor, sunIntensity);
            // scene.fog.color.lerpColors(nightColor, dayColor, sunIntensity);
            scene.background.copy(dayColor); // Forced daytime color
            scene.fog.color.copy(dayColor);  // Forced daytime fog color

            const fogFactor = 1.0 - sunIntensity * 0.5; // Fog increases slightly as sunIntensity drops (less relevant for forced day)
            scene.fog.near = baseFogNear * (0.6 + fogFactor * 0.4);
            scene.fog.far = baseFogFar * (0.85 + fogFactor * 0.15);

            const isMobile = reduceEnvironmentComplexityMobile; // Use consistent variable
            streetLights.forEach(sl => { // Streetlight visuals (emissive part)
                sl.userData.fixture.material.emissiveIntensity = nightFactor * 1.5; // Brighter emissive at night
                sl.userData.light.intensity = isMobile ? nightFactor * 0.2 : nightFactor * 3; // Actual light source intensity
                sl.userData.light.visible = (nightFactor > 0.01); // Only visible if it's somewhat dark
            });

            if (headlightLeft && taillightLeft) { // Car lights
                let headLightBrightness = isRaining ? 0.8 : (nightFactor > 0.6 ? nightFactor * 1.5 : 0);
                headlightLeft.intensity = headLightBrightness; headlightRight.intensity = headLightBrightness;
                headlightLeft.visible = headLightBrightness > 0.01; headlightRight.visible = headLightBrightness > 0.01;

                const baseTaillightIntensity = 0.5; // Brake lights could increase this
                taillightLeft.intensity = baseTaillightIntensity + carVelocity*1.0; // Brighter with speed/acceleration
                taillightRight.intensity = baseTaillightIntensity + carVelocity*1.0;
            }
            if(stars && stars.material) stars.material.opacity = Math.max(0, nightFactor * 1.5 - 0.5); // Stars visible at night

            if (cloudMaterial) cloudMaterial.opacity = 0.3 + sunIntensity * 0.4; // Cloud opacity
            clouds.forEach(cloud => { // Cloud movement
                cloud.position.x += cloud.userData.speed * delta * 100; // Move clouds
                if (cloud.position.x > roadLength * 1.2 + 50) { // Recycle clouds
                    cloud.position.x = -roadLength*1.2-50; cloud.position.z = (Math.random()-0.5)*roadLength*1.5; cloud.position.y = Math.random()*20+40;
                }
            });

            if (isRaining && gameHasStartedAfterCountdown) {
                if (road && road.material.roughness > 0.2) road.material.roughness -= 0.01; // Road gets slicker
                if (road && road.material.metalness < 0.4) road.material.metalness += 0.01; // Road gets shinier
                updateRainParticles_Instanced(delta); 
            } else { // Not raining
                if (road && road.material.roughness < 0.8) road.material.roughness += 0.01; // Road dries
                if (road && road.material.metalness > 0.1) road.material.metalness -= 0.01;
                if (rainInstanceMesh) rainInstanceMesh.visible = false; 
            }

            if (currentPageId === 'game-page' && scene && scene.background) {
                const gamePageDiv = document.getElementById('game-page');
                if (gamePageDiv) gamePageDiv.style.backgroundColor = scene.background.getStyle(); // Sync page bg
            }
        }

        function updateEnemyAI(delta, worldMovementZ) {
            if (!enemyCar || !enemyCar.visible || !carModel || !gameHasStartedAfterCountdown) return;
            // Enemy car Z position is handled by general object scrolling in animate()

            enemyLaneChangeTimer += delta * 1000; // Timer for lane change decision
            if (enemyLaneChangeTimer >= enemyLaneChangeInterval) {
                enemyLaneChangeTimer = 0;
                if (Math.random() < enemyLaneChangeProbability) enemyTargetX = (Math.random() < 0.5 ? -1 : 1) * (roadWidth / 4); // Pick new lane
            }
            enemyCar.position.x = THREE.MathUtils.lerp(enemyCar.position.x, enemyTargetX, 0.03); // Smoothly move to target lane
            if (enemyCar.position.z < carModel.position.z - 40) resetEnemyCar(); // Recycle if far behind player
        }

        function playSound(soundName, loop = false, volume = null) {
            if (sounds[soundName] && typeof Audio !== "undefined" ) {
                sounds[soundName].loop = loop; const S = sounds[soundName];
                let baseVolume = soundName === 'engine' ? 0.3 : 0.5; // Default volumes
                S.volume = volume !== null ? volume * baseVolume : baseVolume; // Apply custom volume or default
                
                // Play only if on game page, not game over, and not counting down (for looped sounds)
                // Non-looped sounds (like collect) can play during countdown briefly
                if ( (currentPageId === 'game-page' && !isGameOver && (!isCountingDown || !loop)) || !loop ) {
                    if (S.paused || !loop || S.currentTime > 0) { // Check if paused or if it's a non-looped sound that can replay
                        const playPromise = S.play();
                        if (playPromise !== undefined) {
                            playPromise.catch(e => { /* console.warn('Audio play prevented for ' + soundName + ':', e) */ });
                        }
                    }
                }
            }
        }

        function stopSound(soundName) {
            if (sounds[soundName] && typeof Audio !== "undefined") {
                sounds[soundName].pause(); 
                if (sounds[soundName].currentTime > 0) sounds[soundName].currentTime = 0; // Reset time for next play
            }
        }

        function updateEngineSound() {
            if(sounds.engine && !isGameOver && currentPageId === 'game-page' && gameHasStartedAfterCountdown) {
                const minPlaybackRate = 0.5, maxPlaybackRate = 2.0;
                const targetPlaybackRate = minPlaybackRate + (carVelocity/maxSpeed * (maxPlaybackRate - minPlaybackRate));
                sounds.engine.playbackRate = THREE.MathUtils.lerp( sounds.engine.playbackRate || 1.0, targetPlaybackRate, 0.15 );
                
                const baseEngineVolume = 0.3, minVolumeFactor = 0.2, maxVolumeFactor = 0.8;
                const dynamicVolumeFactor = minVolumeFactor + (carVelocity/maxSpeed * (maxVolumeFactor - minVolumeFactor));
                let targetVolume = Math.min(baseEngineVolume * dynamicVolumeFactor, 1.0); // Cap volume
                sounds.engine.volume = THREE.MathUtils.lerp( sounds.engine.volume || baseEngineVolume, targetVolume, 0.1 );

                if (sounds.engine.paused && sounds.engine.volume > 0.01 && carVelocity > 0.01) { // If paused but should be playing
                    const playPromise = sounds.engine.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(e => {/* console.warn('Engine sound play prevented on update:', e) */});
                    }
                }
            } else if (sounds.engine && (isGameOver || currentPageId !== 'game-page' || !gameHasStartedAfterCountdown)) {
                 stopSound('engine'); // Stop if game over, not on game page, or not started
            }
        }

        // Initial page display
        showPage(currentPageId);
        const privacyPolicyPage = document.getElementById('privacy-policy-page');
        if (privacyPolicyPage) {
            const dateElement = privacyPolicyPage.querySelector('p strong');
            if (dateElement && dateElement.textContent.includes('[Current Date]')) {
                dateElement.textContent = `Last updated: ${new Date().toLocaleDateString()}`;
            }
        }

    </script>
</body>
</html>
